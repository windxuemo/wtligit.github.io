<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>C++知识汇总 | Page of Wentao Li</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/7.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">C++知识汇总</h1><a id="logo" href="/.">Page of Wentao Li</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">C++知识汇总</h1><div class="post-meta">Mar 12, 2018</div><a class="disqus-comment-count" data-disqus-identifier="2018/03/12/C++/" href="/2018/03/12/C++/#disqus_thread"></a><div class="post-content"><p>1，构造函数，定义如何进行初始化的成员函数称为构造函数。如果没有提供初始化，类会定义一个默认构造函数。<br>2，const把一个对象转化为一个常量，而且是文件的局部变量<br>3，引用，引用是对象的别名，主要用作函数的形参。在引用上的所有操作都是作用在该引用绑定的对象上<br>4，const引用是指向const对象的引用<br>5，typedef为一个类型起新名字，即定义类型的同义词 typedef double w其中w就是double的同义词<br>6，类定义后面要加分号<br>7，使用class来定义类，隐式设定为private；使用struct类定义类，隐式设定为public。<br>8，当我们在头文件中定义了const变量后，每个包含该头文件的源文件都有了自己的const变量，其名称和值都一样<br>9，string的empty()如果是空返回true<br>10，必须是已存在的元素才能用下标操作符进行索引。通过下标操作进行赋值时，不会添加任何元素。<br>11，迭代器iterator，是一种检查容器内元素并遍历元素的数据类型<br>12，与vector不同，一个数组不能用另外一个数组初始化，也不能将一个数组赋值给另一个数组<br>13，数组的长度是固定的<br>14，缓冲区溢出，导致安全问题的最常见原因是缓冲区溢出错误。当我们在编程时没有检查下标，并且引用了越出数组或其他类似数据结构边界的元素时，就会导致这类错误。<br>15，<em>，解引用操作符，对指针进行解引用操作就能获得该指针所指对象的值<br>16，指针用于指向单个对象，提供对所指对象的间接访问string </em>p=&s;<br>17，尽量避免使用指针和数组<br>18，c++使用<em>把一个标识符声明为指针<br>19，若指针保存0值，说明他不指向任何对象<br>20，很多运行错误都源于使用了未初始化的指针<br>21，void</em>,特殊的指针类型，它可以保存任何类型对象的地址<br>22，引用和指针的比较，引用总是指向某个对象，定义引用时没有初始化是错误的；给引用赋值修改的是该引用所关联的对象的值，而不是使引用与另一对象关联<br>23，指针的指针存放指针的存储地址<br>24，使用下标访问数组时，实际上是使用下标访问指针<br>25，指针和const限定符，指向const对象的指针，const double<em> p;const int const</em> p.本身的值不能修改；指向const对象的const指针 const double<em> const p,指向const对象且不能改<br>26，typedef string</em> pstring;const pstring cstr;把cstr定义为指向string类型对象的const指针。<br>27，row行col列<br>28，对于位操作符，由于系统不能确保如何处理其操作数的符号位，所以建议使用unsigned整形操作数<br>29，int i=0;j=++i;j=i++;前一个++i是对i进行加1操作就结束了，代价小；后一个i++，是对i加1以后再更新i的值为2；不管怎么说另个式子的值都是1，不同点在i。<br>30，-&gt;箭头操作符，获取类类型对象的成员<br>31，如果指针的值为0，则在其上做delete操作是合法的，但这样做是没有任何意义<br>32，一旦删除了指针所指向的对象，立即将指针置为0<br>33，throw表达式，错误检测部分使用这种表达式来说明遇到了不可处理的错误；try，错误处理部分使用它来处理异常，以try关键字开始，以多个catch结束，在try中执行的代码所抛出throw的异常会被其中一个catch所处理<br>34，如果使用引用形参的唯一目的是避免复制实参，则应将形参定义为const引用<br>35，千万不能返回局部变量的引用，因为当函数执行完毕时，将释放分配给局部对象的存储空间，此时，对局部对象的引用就会指向不确定的内存。<br>36，static局部变量，这种对象一旦被创建，在程序结束前都不会被撤销，当定义静态局部对象的函数结束时，静态局部变量不会被撤销，在该函数被多次调用的过程中，静态局部变量会持续存在并保持它的值。<br>37，static全局变量与普通的全局变量有什么区别：<br>static全局变量只初使化一次，防止在其他文件单元中被引用; 　　<br>static局部变量和普通局部变量有什么区别：<br>static局部变量只被初始化一次，下一次依据上一次结果值； 　　<br>static函数与普通函数有什么区别：<br>static函数在内存中只有一份，普通函数在每个被调用中维持一份拷贝<br>38，inline内联函数，内联函数避免了写成函数的额外执行开销<br>39，this指针，每个成员函数都有一个额外的隐含的形参this，在调用成员函数是，形参this初始化为调用函数的对象的地址<br>40， 构造函数struct TreeNode {</p>
<ul>
<li>int val;</li>
<li>TreeNode *left;</li>
<li>TreeNode *right;</li>
<li>TreeNode(int x) : val(x), left(NULL), right(NULL) {}</li>
<li>};//这里展示的是构造函数初始化列表，初始化cosnt或引用类型数据成员的唯一机会是在构造函数初始化列表中<br>41，名字查找发生在类型检查之前<br>42，重载确定是三个步骤，候选函数，查找与被调函数同名的函数；选择可行函数，；寻找最佳匹配<br>43，c.push_front(t)在容器的前端添加值为t的元素<br>44，对于map容器，如果下标所表示的键在容器中不存在，则添加新元素<br>45，set不支持下标操作符<br>46，在类内部定义的成员函数，将自动作为inline处理，即内联函数，也就是说，当他们被调用时，编译器将试图在同一行内扩展该函数<br>47，在一个给定的源文件中，一个类只能被定义一次，如果在多个文件中定义一个类，那么每个文件中的定义必须是完全相同的<br>48，只要类名一出现就可以认为该类已声明，因此，类的数据成员可以是指向自身类型的指针或引用<br>49，this，指向该类对象的一个指针；当我们需要将一个对象作为整体引用而不是引用对象的一个成员时，必须显示地引用this；比如set函数<br>50，在非const成员函数中，this类型是一个指向类类型的const指针，可以改变this所指向的值，但不能改变this所保存的地址；在const成员函数中，this的类型是一个指向const类型对象的const指针，既不能改变this所指的对象，也不能改变this所保存的地址<br>51，mutable声明可变数据成员<br>52，构造函数可以重载，实参决定使用哪个构造函数，构造函数自动执行，const构造函数是不必要的<br>53，成员被初始化的次序就是定义成员的次序<br>54，只有当一个类没有定义构造函数时，编译器才会自动生成一个默认构造函数<br>55，当构造函数被声明为<strong>explicit</strong>时，编译器将不使用它作为转换操作符<br>56，友元机制允许一个类将对其非共有成员的访问权授权指定的函数或类<br>57，static成员函数没有this指针<br>58，static数据成员必须在类定义体的外部定义<br>59，const static数据成员就可以在类的定义体中进行初始化<br>60，普通成员都是给定类的每个对象的组成部分，static成员独立于任何对象而存在，不是类类型对象的组成部分<br>61，复制构造函数只有单个形参，而且该形参是对本类类型对象的引用（常用const修饰），这样的构造函数即复制构造函数。复制初始化首先使用指定构造函数创建一个临时对象，然后用复制构造函数将那个临时对象复制到正在创建的对象<br>62，vector<string> secv(5);编译器首先使用string默认构造函数创建一个临时值来初始化secv，然后使用复制构造函数将临时值复制到secv的每个元素。<br>63，如果没有定义复制构造函数，编译器会为我们合成一个，与合成默认构造函数不同，即使我们定义了其他构造函数，也会合成复制构造函数。合成复制构造函数的行为是：执行逐个成员初始化，将新对象初始化为原对象的副本<br>64，复制构造函数就是接受单个类类型引用形参的构造函数<br>65，为了防止复制，类必须显示声明其复制构造函数为private<br>66，析构函数自动回收或释放资源。撤销类对象时会自动调用析构函数；动态分配的对象只有在指向该对象的指针被删除时才撤销，如果没有删除指向动态对象的指针，则不会运行该对象的析构函数<br>67，当对象的引用或指针超出作用域时，不会运行析构函数，只有删除指向动态分配对象的指针或实际对象（而不是对象的引用）超出作用域时，才会运行析构函数<br>68，合成析构函数按成员在类中声明次序的逆序撤销成员<br>69，析构函数没有返回值，没有形参，因为不能指定任何形参，所以不能重载析构函数，虽然可以为一个类定义多个构造函数，但只能提供一个析构函数，应用于类的所有对象<br>70，包含指针的类需要特别注意复制控制，因为复制指针时只复制指针中的地址，而不会复制指针指向的对象<br>71，智能指针类，将一个计数器与类指向的对象相关联，使用技术跟踪该类有多少个对象共享同一指针，使用计数为0时，删除对象。<br>72，作为类成员的重载函数，其形参看起来比操作数数目少1.作为成员函数的操作符有一个隐含的this形参，限定为第一个操作数<br>73，操作符定义为非成员函数时，通常必须将它们设置为所操作类的友元<br>74，为类设计重载操作符的时候，必须选择是将操作符设置为类成员还是普通非成员函数。有一些原则：赋值=下标[]调用()和成员访问-&gt;必须为成员；复合赋值操作符+=应为成员；改变对象状态的如自增++应为成员；而对称的操作符如算数操作符，相等操作符，关系操作符和位操作符应为非成员函数<br>75，C++中预定义的运算符的操作对象只能是基本数据类型。但实际上，对于许多用户自定义类型（例如类），也需要类似的运算操作。这时就必须在C++中重新定义这些运算符，赋予已有运算符新的功能，使它能够用于特定类型执行特定的操作。运算符重载的实质是函数重载<br>76，(1) 除了类属关系运算符”.”、成员指针运算符”.*”、作用域运算符”::”、sizeof运算符和三目运算符”?:”以外，C++中的所有运算符都可以重载。</string></li>
</ul>
<p>(2) 重载运算符限制在C++语言中已有的运算符范围内的允许重载的运算符之中，不能创建新的运算符。</p>
<p>(3) 运算符重载实质上是函数重载，因此编译程序对运算符重载的选择，遵循函数重载的选择原则。</p>
<p>(4) 重载之后的运算符不能改变运算符的优先级和结合性，也不能改变运算符操作数的个数及语法结构。</p>
<p>(5) 运算符重载不能改变该运算符用于内部类型对象的含义。它只能和用户自定义类型的对象一起使用，或者用于用户自定义类型的对象和内部类型的对象混合使用时。</p>
<p>(6) 运算符重载是针对新类型数据的实际需要对原有运算符进行的适当的改造，重载的功能应当与原有功能相类似，避免没有目的地使用重载运算符。<br>77，(1) 一般情况下，单目运算符最好重载为类的成员函数；双目运算符则最好重载为类的友元函数。</p>
<p>(2) 以下一些双目运算符不能重载为类的友元函数：=、()、[]、-&gt;。</p>
<p>(3) 类型转换函数只能定义为一个类的成员函数而不能定义为类的友元函数。</p>
<p>(4) 若一个运算符的操作需要修改对象的状态，选择重载为成员函数较好。</p>
<p>(5) 若运算符所需的操作数（尤其是第一个操作数）希望有隐式类型转换，则只能选用友元函数。</p>
<p>(6) 当运算符函数是一个成员函数时，最左边的操作数（或者只有最左边的操作数）必须是运算符类的一　个类对象（或者是对该类对象的引用）。如果左边的操作数必须是一个不同类的对象，或者是一个内部　类型的对象，该运算符函数必须作为一个友元函数来实现。</p>
<p>(7) 当需要重载运算符具有可交换性时，选择重载为友元函数。<br>78，输入操作符必须处理错误和文件结束的可能性<br>79，为了与内置操作符保持一致，加法返回一个右值，而不是一个引用<br>80，C++中，多态性仅用于通过继承而相关联的类型的引用或指针<br>81，在C++中，基类必须指出希望派生类重定义哪些函数，定义为virtual的函数,是基类期待派生类重新定义的，基类希望派生类继承的函数不能定义为虚函数<br>82，在C++中，通过基类的引用（或指针）调用虚函数时，发生动态绑定。引用（或指针）既可以指向基类对象也可以指向派生类对象。用引用（或指针）调用的虚函数在运行时确定，被调用的函数是引用（或指针）所指对象的实际类型所定义的<br>83，除了构造函数外，任意非static成员函数都可以是虚函数，保留字virtual只在类内部的成员函数成声明中出现<br>84，派生类只能通过派生类对象访问其<strong>基类</strong>的protected成员，派生类对其<strong>基类类型</strong>对象的protected成员没有特殊访问权限；如，buick_item定义了一个成员函数，接受一个BUICK_ITEM对象的引用和一个ITEM_BASE对象的引用，该函数可以访问自己对象的protected成员以及BUICK_ITEM形参的protected成员，但是他不能访问ITEM_BASE形参的protected成员<br>85，派生类列表class classname:access-label base-class如：class C :private Base    //基类Base的派生类C（私有继承）<br>86，派生类一般会重定义所继承的虚函数，如果派生类没有重定义某个虚函数，则使用基类中定义的版本<br>87，用作基类的类必须是已定义的，可以用派生类做基类，如果需要声明但不实现一个派生类，则声明包含类名但不包含派生列表<br>88，多态一词最初来源于希腊语，意思是具有多种形式或形态的情形，在C++中是指同样的消息被不同类型的对象接收时导致不同的行为，这里讲的消息就是指对象的成员函数的调用，而不同的行为是指不同的实现。也就是调用了不同的函数。<br>89，态性从系统实现的角度来讲可以划分为两类：静态多态（也叫编译时多态性）和动态多态（又称运行时多态性），以前学过的函数重载和运算符的重载属于静态多态性，在程序编译时就能决定调用的是哪一个函数，静态多态是通过函数的重载来实现的（运算符重载实际上也属于函数的重载）。动态多态性是程序运行过程中才动态地确定操作所针对的对象，运行时多态性是通过虚函数来实现的。<br>90，只有通过引用或指针调用，虚函数才在运行时确定。只有在这些情况下，直到运行时才知道对象的动态类型<br>91，虚函数表的作用是生成虚函数的偏移地址，真正的地址需要将对象实例化后的地址+函数的偏移地址！<br>也就是说虚函数不能像静态函数那样直接用call 函数名来调用。虚函数的地址在编译期没有被确定<br>92，非虚函数总是在编译时根据调用该函数的对象、引用或指针的类型而确定<br>93，在某些情况下，希望覆盖虚函数机制并强制函数调用使用虚函数的特定版本，可以使用作用域操作符::<br>94，可以使用using声明从命名空间使用名字，也可以使用using声明访问基类中的名字<br>95，class默认private，struce默认public<br>96，友元关系不能继承，基类中的友元对派生类的成员没有特殊访问权限<br>97，无论从基类派生出多少个派生类，每个static成员只有一个实例<br>98，可以将派生类对象的引用转换为基类子对象的引用，没有从基类引用到派生类引用的自动转换；一般可以使用派生类型的对象对基类类型的对象进行初始化或赋值，但是没有从派生类型对象到基类类型对象的直接转换，如，Item_base item;Bulk_item bulk;Item_base item(bulk);其中bulk是派生类，可以用于基类的初始化或赋值。<br>99，构造函数和复制控制成员不能继承<br>100，派生类的构造函数受继承关系的影响，每个派生类构造函数除了初始化自己的数据成员之外，还要初始化基类<br>101，派生类构造函数的初始化列表只能初始化派生类的成员，不能直接初始化继承成员。相反，派生类构造函数通过将基类包含在构造函数初始化列表中来间接初始化继承成员。<br>102，派生类只能初始化自己的直接基类，要尊重基类接口<br>103，在C++中，3种对象需要复制，此时拷贝构造函数会被调用</p>
<p>1）一个对象以值传递的方式传入函数体</p>
<p>2）一个对象以值传递的方式从函数返回</p>
<p>3）一个对象需要通过另一个对象进行初始化<br>104，什么时候编译器会生成默认的拷贝构造函数：</p>
<p>1）如果用户没有自定义拷贝构造函数，并且在代码中使用到了拷贝构造函数，编译器就会生成默认的拷贝构造函数。但如果用户定义了拷贝构造函数，编译器就不在生成。</p>
<p>2）如果用户定义了一个构造函数，但不是拷贝构造函数，而此时代码中又用到了拷贝构造函数，那编译器也会生成默认的拷贝构造函数。<br>105，  int m_i<br>  A(const A&amp; other):m_i(other.m_i)<br>{<br>  Cout&lt;&lt;”拷贝构造函数”&lt;&lt;endl;<br>}<br>106，派生类析构函数不负责撤销基类对象的成员，编译器总是显示调用派生类对象基类部分的析构函数<br>107，在继承情况下，派生类的作用域嵌套在基类作用域中<br>108，与基类成员同名的派生类成员将屏蔽对基类成员的直接访问<br>109，如果派生类重定义了重载成员，则通过派生类型只能访问派生类中重定义的那些成员<br>110，虚函数为什么必须在基类和派生类中拥有同一原型？如果基类成员与派生类成员接受的实参不同，就没有办法通过基类类型的引用或指针调用派生类函数<br>111，名字查找与继承：首先确定进行函数调用的对象，引用或指针的静态类型，然后在该类中查找，顺着类的继承链找<br>112，在许多情况下，在基类中不能对虚函数给出有意义的实现，而把它声明为纯虚函数，它的实现留给该基类的派生类去做。这就是纯虚函数的作用　C++中包含纯虚函数的类，被称为是“抽象类”。抽象类不能使用new出对象，只有实现了这个纯虚函数的子类才能new出对象。</p>
<p>　　C++中的纯虚函数更像是“只提供申明，没有实现”，是对子类的约束，是“接口继承”。</p>
<p>　　C++中的纯虚函数也是一种“运行时多态”。<br>113，句柄类存储和管理基类指针，因为句柄类使用指针执行操作，虚函数的行为将在运行时根据句柄实际绑定的对象的类型而变化，因此句柄的用户可以获得动态行为而无需操心指针的管理<br>114，可以把句柄当作一个指向指针的指针来理解，句柄一般是指向系统的资源的位置，可以说也是地址<br>115，面向对象编程所依赖的多态性称为运行时多态性，泛型编程所依赖的多态性称为编译时多态性或参数式多态性<br>116，模板类型参数由关键字class或typename后接说明符构成<br>117，实例化的时候可以发现类型相关的错误<br>118，模板中要用不同的实参，要用两个类型参数来定义：template<typename a,typename="" b=""><br>119，export关键字能够指明给定的定义可能会需要在其他文件中产生实例化<br>120，包含编译模型，编译器必须看到用到的所有的模板的定义，一般可以通过在声明函数模板或类模板的头文件添加一条#include指示其定义可用，该#include引入了包含相关定义的源文件；在分别编译模型中，编译器会跟踪相关的模板定义<br>121，类模板的成员函数只有为程序所用才进行实例化<br>122，类模板中可以出现三种友元声明：普通非模板类或函数的友元声明，将友元关系授予明确指定的类或函数；类模板或函数模板的友元声明，授予对友元所有实例的访问权；只授予对类模板或函数模板的特定实例的访问权的友元声明<br>123，任意类（模板或非模板）可以拥有本身为类模板或函数模板的成员，这种成员称为成员模板，成员模板不能为虚<br>124，模板特化：一个或多个模板形参的实际类型或实际值是指定的，形式如：关键字template后面接一对空的尖括号&lt;&gt;；再接模板名和一对尖括号，尖括号中指定这个特化定义的模板形参；函数形参表；函数体<br>125，在特化中省略空的模板形参表template&lt;&gt;会有令人惊讶的结果，如果缺少该特化语法，则结果是声明该函数的重载非模板版本<br>126，产生模板的特定类型实例的过程称为实例化<br>127，函数模板可以重载，可以定义有相同名字但形参数目或类型不同的多个函数模板，也可以定义与函数模板有相同名字的普通非模板函数<br>128，重载赋值运算符必须返回对*this的引用<br>129，const总结：<a href="http://blog.csdn.net/Eric_Jo/article/details/4138548" target="_blank" rel="noopener">http://blog.csdn.net/Eric_Jo/article/details/4138548</a><br>130，仅当const参数是一个引用或指针时，C++才允许基于const类型进行函数重载。<br>131，类定义下标操作符时，一般需要定义两个版本，一个为非const成员并返回引用，另一个为const成员，并返回const引用<br>132，转换操作符是一种特殊的类成员函数，它定义将类类型值转变为其他类型值的转换，转换类型符在类定义体内声明，在保留字operator之后跟着转换的目标类型，转换函数必须是成员函数，不能指定返回类型，并且形参表必须为空<br>class SmallInt {<br>public:<br>  SmallInt(int i = 0): val(i)<br>  {<br>   if (i &lt; 0 || i &gt; 255)<br>    throw std::out_of_range(“Bad SmallInt initializer”);<br>  }<br>  operator int() const { return val; }<br>private:<br>  std::size_t val;<br>};</typename></p>
</div><div class="tags"></div><div class="post-nav"><a class="pre" href="/2018/03/15/treeTraverse/">二叉树的四种遍历</a><a class="next" href="/2018/03/11/Sort/">数据结构中十种经典排序方法汇总(C++)</a></div><div id="disqus_thread"><div class="btn_click_load"><button class="disqus_click_btn">阅读评论 「请确保 disqus.com 可以正常加载」</button></div><script>var disqus_shortname = 'wtli';
var disqus_identifier = '2018/03/12/C++/';
var disqus_title = 'C++知识汇总';
var disqus_url = 'http://yoursite.com/2018/03/12/C++/';
$('.btn_click_load').click(function() {
  (function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
  $('.btn_click_load').css('display','none');
});
$.ajax({
  url: 'https://disqus.com/next/config.json',
  timeout: 3000,
  type: 'GET',
  success: (function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    $('.btn_click_load').css('display','none');
  })(),
  error: function() {
    $('.btn_click_load').css('display','block');
  }
});</script><script id="dsq-count-scr" src="//wtli.disqus.com/count.js" async></script></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://yoursite.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/03/16/treeConstruct/">树的重建</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/03/16/LCS/">LCS</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/03/15/treeTraverse/">二叉树的四种遍历</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/03/12/C++/">C++知识汇总</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/03/11/Sort/">数据结构中十种经典排序方法汇总(C++)</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/03/10/Datastructure/">数据结构知识整理</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/02/26/VLOOKUP/">Excel怎样把相同列数据合并到一行</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/02/02/Interview/">面试知识整理</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/01/30/UT-easymock/">单元测试整理（六）—— 使用EasyMock和JUnit进行单元测试</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/01/29/UT-what/">单元测试整理（一）——单元测试是什么，有什么好处</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-comment-o"> 最近评论</i></div><script type="text/javascript" src="//wtli.disqus.com/recent_comments_widget.js?num_items=5&amp;hide_avatars=1&amp;avatar_size=32&amp;excerpt_length=20&amp;hide_mods=1"></script></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://github.com/wtligit" title="GitHub" target="_blank">GitHub</a><ul></ul><a href="http://blog.csdn.net/potatostyles" title="CSDN" target="_blank">CSDN</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">Page of Wentao Li.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.2.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.2.5/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>