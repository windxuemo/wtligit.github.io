<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>单元测试整理（三）——JUnit 测试组成和注释 | Page of Wentao Li</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/7.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">单元测试整理（三）——JUnit 测试组成和注释</h1><a id="logo" href="/.">Page of Wentao Li</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">单元测试整理（三）——JUnit 测试组成和注释</h1><div class="post-meta">Jan 29, 2018</div><a class="disqus-comment-count" data-disqus-identifier="2018/01/29/UT-constitute/" href="/2018/01/29/UT-constitute/#disqus_thread"></a><div class="post-content"><h2 id="JUnit-测试的组成"><a href="#JUnit-测试的组成" class="headerlink" title="JUnit 测试的组成"></a>JUnit 测试的组成</h2><p>在这里我们主要展示除了上一章提到的基本的测试方法之外的几个很好用的测试方法。suite，setUp()和tearDown()，以及异常处理。</p>
<h3 id="suite集合测试用例"><a href="#suite集合测试用例" class="headerlink" title="suite集合测试用例"></a>suite集合测试用例</h3><p>如上一章在最后展示的JUnit测试骨架的最小要求，我们可以看到一个测试类包含一些测试方法，每个方法包含一个或者多个断言语句。但是，实际上测试类也能调用其他测试类：单独的类、包，甚至是完整的一个系统。而这种调用就是通过创建<strong>test suite</strong>来实现的。<br><strong>test suite</strong>： 测试套件（test suite）有时也称为验证套件（validation suite），是许多测试用例的集合，测试用例可用来测试一程式是否正确工作，测试套件包括许多测试用例，一般也会有针对测试用例及其测试目的的详细说明，在进行测试时的系统组态资讯以及测试前需进行的步骤。<strong>简单来说，可以把测试套件理解为测试用例的集合</strong>。</p>
<p>任何测试类都可以包含一个名为<strong>suite</strong>的静态方法，我们可以通过suite()方法来返回任何想要的测试集合，而没有suite()方法的话，JUnit会自动运行所有的test方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public static TEST suite</span><br></pre></td></tr></table></figure></p>
<p>现在考虑这样一个例子：假设我们现在有一个普通的测试例子TestClassOne,我们希望执行其中所有的测试；有一个TestClassTwo我们希望执行其中的一部分测试，而对测试例子的选择就可以通过suite来实现。而且在TestClassTwo.java中<strong>我们可以看到给构造函数的String参数是做什么用的了：它让TestCase返回了一个对命名测试方法的引用。</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// TestClassOne.java</span><br><span class="line">import junit.framework.*;</span><br><span class="line">public class TestClassOne extends TestCase &#123;</span><br><span class="line">	public TestClassOne(String method) &#123;</span><br><span class="line">		super(method);</span><br><span class="line">	&#125;</span><br><span class="line">	public void testadd() &#123;</span><br><span class="line">		assertEquals(4,2+2);</span><br><span class="line">	&#125;</span><br><span class="line">	public void testsub() &#123;</span><br><span class="line">		assertEquals(0,2-2);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// TestClassTwo</span><br><span class="line">import junit.framework.*;</span><br><span class="line">public class TestClassTwo extends TestCase &#123;</span><br><span class="line">	public TestClassTwo(String method) &#123;</span><br><span class="line">		super(method);</span><br><span class="line">	&#125;</span><br><span class="line">	public void testmul() &#123;</span><br><span class="line">		assertEquals(4,2*2);</span><br><span class="line">	&#125;</span><br><span class="line">	public void testdiv() &#123;</span><br><span class="line">		assertEquals(0.667,2/3);</span><br><span class="line">	&#125;</span><br><span class="line">	public static Test suite() &#123;</span><br><span class="line">		TestSuite suite = new TestSuite();</span><br><span class="line">		//此时我们可以看到给构造函数的String参数让TestCase返回了一个对命名测试方法的引用</span><br><span class="line">		suite.addTest(new TestClassTwo(&quot;testmul&quot;));</span><br><span class="line">		return suite;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里我们用TestClassComposite演示了用一个高一级别的测试来组合两个测试类的方法，这段代码将执行三个方法，分别是：testadd，testsub和testmul。testdiv被滤掉了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// TestClassComposite</span><br><span class="line">import junit.framework.*;</span><br><span class="line">public class TestClassComposite extends TestCase &#123;</span><br><span class="line">	public TestClassComposite(String method) &#123;</span><br><span class="line">		super(method);</span><br><span class="line">	&#125;</span><br><span class="line">	static public Test suite() &#123;</span><br><span class="line">		TestSuite suite = new TestSuite();</span><br><span class="line">		//include everything in TestClassOne</span><br><span class="line">		suite.addTestSuite(TestClassOne.class);</span><br><span class="line">		//use the suite method in TestClassTwo</span><br><span class="line">		suite.addTest(TestClassTwo.suite());</span><br><span class="line">		return suite;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Setup和Tear-down用于环境-资源的建立和清理"><a href="#Setup和Tear-down用于环境-资源的建立和清理" class="headerlink" title="Setup和Tear-down用于环境/资源的建立和清理"></a>Setup和Tear-down用于环境/资源的建立和清理</h3><p>每个测试的运行都应该是相互独立的，在每个测试开始之前，会需要重新设置某些测试环境，在测试完成后释放这些资源。JUnit的TestCase提供了两个方法以供改写，分别用于环境/资源的建立和清理<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">protected void setUp();</span><br><span class="line">protected void tearDown();</span><br></pre></td></tr></table></figure></p>
<p>举个例子，如果我们的每个测试都需要进行数据库连接的话，借助于Setup和Tear-down就不用再每个测试方法中重复写数据库连接的语句，而只需在Setup和Tear-down中分别建立和释放连接<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// Per-method的Setup和Tear-down用于环境/资源的建立和清理</span><br><span class="line">public class TestDB extends TestCase &#123;</span><br><span class="line">    private Connection dbConnection;</span><br><span class="line">	public TestDB(String method) &#123;</span><br><span class="line">		super(method);</span><br><span class="line">	&#125;</span><br><span class="line">    protected void setUp() &#123;</span><br><span class="line">    	dbConnection = new Connection(&quot;oracle&quot;,123456,&quot;wtli&quot;);</span><br><span class="line">    	dbConnection.connect();</span><br><span class="line">    &#125;</span><br><span class="line">    protected void tearDown() &#123;</span><br><span class="line">    	dbConnection.disconnect();</span><br><span class="line">    	dbConnection = null;</span><br><span class="line">    &#125;</span><br><span class="line">    public void testAdminAccess() &#123;</span><br><span class="line">    	...</span><br><span class="line">    &#125;</span><br><span class="line">    public void testGuestAccess() &#123;</span><br><span class="line">    	...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上例的执行过程为setUp()-&gt;testAdminAccess()-&gt;tearDown()-&gt;setUp()-&gt;testGuestAccess()-&gt;tearDown()。<br>一般情况下，我们只需按上例一样，为每个方法设置运行环境。但是在一些情况下，我们需要为整个test suite设置一些环境，以及在test suite中的所有方法都执行完成后做一些清理工作。此时我们需要比Per-method的Setup和Tear-down稍微复杂一点的，Per-suite的Setup和Tear-down。我们直接在上面的TestClassTwo做一些改变。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">// Per-suite的Setup和Tear-down用于环境/资源的建立和清理</span><br><span class="line">import junit.framework.*;</span><br><span class="line">import junit.extensions.*;</span><br><span class="line">public class TestClassTwo extends TestCase &#123;</span><br><span class="line">	public TestClassTwo(String method) &#123;</span><br><span class="line">		super(method);</span><br><span class="line">	&#125;</span><br><span class="line">	public void testmul() &#123;</span><br><span class="line">		assertEquals(4,2*2);</span><br><span class="line">	&#125;</span><br><span class="line">	public void testdiv() &#123;</span><br><span class="line">		assertEquals(0.667,2/3);</span><br><span class="line">	&#125;</span><br><span class="line">	public static Test suite() &#123;</span><br><span class="line">		TestSuite suite = new TestSuite();</span><br><span class="line">		/*此时我们可以看到给构造函数的String参数是做什么用的了：</span><br><span class="line">		它让TestCase返回了一个对命名测试方法的引用*/</span><br><span class="line">		suite.addTest(new TestClassTwo(&quot;testmul&quot;));</span><br><span class="line">		TestSetup wrapper = new TestSetup(suite) &#123;</span><br><span class="line">			protected void setUp() &#123;</span><br><span class="line">				oneTimeSetup();</span><br><span class="line">			&#125;</span><br><span class="line">			protected void tearDown() &#123;</span><br><span class="line">				oneTimeTearDown();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">		return wrapper;</span><br><span class="line">	&#125;</span><br><span class="line">	public static void oneTimeSetup() &#123;</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line">	public static void oneTimeTearDown() &#123;</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到在Per-suite的Setup和Tear-down中，需要提供所需测试的一个suite，并且把它包装进TestSetup对象。<br><img src="https://raw.githubusercontent.com/wtligit/pic-repo/master/pic/codeOrder.png" alt="代码的执行顺序"></p>
<h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><p>如果你是从<a href="http://wtli.top/2018/01/29/UT-assert/" target="_blank" rel="noopener">单元测试整理（二）——断言篇，首个单元测试程序</a>看过来的，那么应该有印象，我们在第一个单元测试程序中对被测程序的抛出异常就做了测试<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public void testisEmpty() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        Largest.largest(new int[] &#123;&#125;);</span><br><span class="line">        fail(&quot;An exception should been thrown!&quot;);</span><br><span class="line">    &#125;catch(RuntimeException e) &#123;</span><br><span class="line">        assertTrue(true);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>被测试的代码被try/catch包含于内。预期这个方法会抛出一个异常，如果没有会把测试置为失败，如果异常如期发生，会跳到catch并且记录下断言以做统计使用。实际上在测试中异常是一个好东西，它可以告诉我们哪里出错了。而在这里选择assertTrue一是因为这个断言可以判断流程是否会如约到达这个地方，而且<strong>assertTrue没有被调用不会产生任何错误。</strong></p>
<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>注释就好像你可以在你的代码中添加并且在方法或者类中应用的元标签。JUnit 中的这些注释为我们提供了测试方法的相关信息，哪些方法将会在测试方法前后应用，哪些方法将会在所有方法前后应用，哪些方法将会在执行中被忽略。<br>JUnit 中的注释的列表以及他们的含义：</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>注释</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>@Test</td>
<td>这个注释说明依附在 JUnit 的 public void 方法可以作为一个测试案例</td>
</tr>
<tr>
<td>2</td>
<td>@Before</td>
<td>有些测试在运行前需要创造几个相似的对象。在 public void 方法加该注释<br>是因为该方法需要在 test 方法前运行</td>
</tr>
<tr>
<td>3</td>
<td>@After</td>
<td>如果你将外部资源在 Before 方法中分配，那么你需要在测试运行后释放他们。<br>在 public void 方法加该注释是因为该方法需要在 test 方法后运行</td>
</tr>
<tr>
<td>4</td>
<td>@BeforeClass</td>
<td>在 public void 方法加该注释是因为该方法需要在类中所有方法前运行</td>
</tr>
<tr>
<td>5</td>
<td>@AfterClass</td>
<td>它将会使方法在所有测试结束后执行。这个可以用来进行清理活动</td>
</tr>
<tr>
<td>6</td>
<td>@Ignore</td>
<td>这个注释是用来忽略有关不需要执行的测试的</td>
</tr>
</tbody>
</table>
<p>其中：<br>beforeClass() 方法首先执行，并且只执行一次。<br>afterClass() 方法最后执行，并且只执行一次。<br>before() 方法针对每一个测试用例执行，但是是在执行测试用例之前。<br>after() 方法针对每一个测试用例执行，但是是在执行测试用例之后。<br>在 before() 方法和 after() 方法之间，执行每一个测试用例。</p>
<p>下一章<a href="http://wtli.top/2018/01/29/UT-content/" target="_blank" rel="noopener">单元测试整理（四）——测试哪些内容及边界条件</a>将介绍用Right-BICEP确定测试哪些内容，用CORRECT找寻边界条件</p>
</div><div class="tags"></div><div class="post-nav"><a class="pre" href="/2018/01/29/UT-content/">单元测试整理（四）——测试哪些内容及边界条件</a><a class="next" href="/2018/01/29/UT-assert/">单元测试整理（二）——断言篇，首个单元测试程序</a></div><div id="disqus_thread"><div class="btn_click_load"><button class="disqus_click_btn">阅读评论 「请确保 disqus.com 可以正常加载」</button></div><script>var disqus_shortname = 'wtli';
var disqus_identifier = '2018/01/29/UT-constitute/';
var disqus_title = '单元测试整理（三）——JUnit 测试组成和注释';
var disqus_url = 'http://yoursite.com/2018/01/29/UT-constitute/';
$('.btn_click_load').click(function() {
  (function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
  $('.btn_click_load').css('display','none');
});
$.ajax({
  url: 'https://disqus.com/next/config.json',
  timeout: 3000,
  type: 'GET',
  success: (function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    $('.btn_click_load').css('display','none');
  })(),
  error: function() {
    $('.btn_click_load').css('display','block');
  }
});</script><script id="dsq-count-scr" src="//wtli.disqus.com/count.js" async></script></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://yoursite.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/03/16/LCS/">LCS</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/03/15/treeTraverse/">二叉树的四种遍历</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/03/12/C++/">C++知识汇总</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/03/11/Sort/">数据结构中十种经典排序方法汇总(C++)</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/03/10/Datastructure/">数据结构知识整理</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/02/26/VLOOKUP/">Excel怎样把相同列数据合并到一行</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/02/02/Interview/">面试知识整理</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/01/30/UT-easymock/">单元测试整理（六）—— 使用EasyMock和JUnit进行单元测试</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/01/29/UT-what/">单元测试整理（一）——单元测试是什么，有什么好处</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/01/29/UT-mock/">单元测试整理（五）—— Mock篇，测试一个servlet</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-comment-o"> 最近评论</i></div><script type="text/javascript" src="//wtli.disqus.com/recent_comments_widget.js?num_items=5&amp;hide_avatars=1&amp;avatar_size=32&amp;excerpt_length=20&amp;hide_mods=1"></script></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://github.com/wtligit" title="GitHub" target="_blank">GitHub</a><ul></ul><a href="http://blog.csdn.net/potatostyles" title="CSDN" target="_blank">CSDN</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">Page of Wentao Li.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.2.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.2.5/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>