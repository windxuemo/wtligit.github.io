<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>单元测试整理（二）——断言篇，首个单元测试程序 | Page of Wentao Li</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/7.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">单元测试整理（二）——断言篇，首个单元测试程序</h1><a id="logo" href="/.">Page of Wentao Li</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">单元测试整理（二）——断言篇，首个单元测试程序</h1><div class="post-meta">Jan 29, 2018</div><a class="disqus-comment-count" data-disqus-identifier="2018/01/29/UT-assert/" href="/2018/01/29/UT-assert/#disqus_thread"></a><div class="post-content"><h2 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h2><p>单元测试主要是用来验证所测代码是否和程序员的期望一致，如下所示，在实际操作中，我们可以编写一个函数assertTure()来验证预期条件是否满足，也可以进一步编写一个函数assertEquals()来判断两个数是否相等。事实上诸如此类判断函数，我们称之为断言。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public void assertTrue(boolean condition)&#123;</span><br><span class="line">    if(!condition)&#123;</span><br><span class="line">        abort();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">--------------------------------------------</span><br><span class="line">int a = 5;</span><br><span class="line">//如果由于某种原因，当调用assertTrue()的时候，a并不等于5，上面程序将终止</span><br><span class="line">assertTure(a == 5);</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void assertEquals(int a, int b)&#123;</span><br><span class="line">    assertTrue(a == b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>断言</strong> 是一种放在程序中的一阶逻辑（如一个结果为真或是假的逻辑判断式），目的是为了标示与验证程序开发者预期的结果－当程序运行到断言的位置时，对应的断言应该为真。若断言不为真时，程序会中止运行，并给出错误消息。</p>
<h2 id="常用断言"><a href="#常用断言" class="headerlink" title="常用断言"></a>常用断言</h2><table>
<thead>
<tr>
<th>序号</th>
<th>方法描述</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>void assertEquals(boolean expected, boolean actual)</td>
<td>检查两个变量或者等式是否平衡</td>
</tr>
<tr>
<td>2</td>
<td>void assertTrue(boolean expected, boolean actual)</td>
<td>检查条件为真</td>
</tr>
<tr>
<td>3</td>
<td>void assertFalse(boolean condition)</td>
<td>检查条件为假</td>
</tr>
<tr>
<td>4</td>
<td>void assertNotNull(Object object)</td>
<td>检查对象不为空</td>
</tr>
<tr>
<td>5</td>
<td>void assertNull(Object object)</td>
<td>检查对象为空</td>
</tr>
<tr>
<td>6</td>
<td>void assertSame(boolean condition)</td>
<td>检查两个相关对象是否指向同一个对象</td>
</tr>
<tr>
<td>7</td>
<td>void assertNotSame(boolean condition)</td>
<td>检查两个相关对象是否不指向同一个对象</td>
</tr>
<tr>
<td>8</td>
<td>void assertArrayEquals(expectedArray, resultArray)</td>
<td>检查两个数组是否相等</td>
</tr>
</tbody>
</table>
<p>上表列举了常用的八种断言，事实上我们在实际使用中并不需要自己编写这些基础的断言，java的编程框架JUnit已经集成了这些断言和一系列单元测试相关的函数。<br><strong>JUnit</strong> 是一个 Java 编程语言的单元测试框架（回归测试框架）。JUnit 在测试驱动的开发方面有很重要的发展，是起源于 JUnit 的一个统称为 xUnit 的单元测试框架之一。JUnit 促进了“先测试后编码”的理念，强调建立测试数据的一段代码，可以先测试，然后再应用。这个方法就好比“测试一点，编码一点，测试一点，编码一点……”，增加了程序员的产量和程序的稳定性，可以减少程序员的压力和花费在排错上的时间。</p>
<h2 id="第一个单元测试程序"><a href="#第一个单元测试程序" class="headerlink" title="第一个单元测试程序"></a>第一个单元测试程序</h2><p>我们将从这样一个简单的例子开始：查找一个list中的最大值。这次我们不妨用一种先想测试，再写代码的编程思想。<br>1，首先，这个程序要保证一个list，如{7,8,9}，可以把9输出出来<br>2，然后呢，上面给了一个顺序的list，不失一般性，这个程序不应该是顺序敏感的，所以{7,9,8}，{9,8,7}等也要输出9<br>3，我发现，上面的list都是正数，那么负数和0呢？{-7，-8，-9}应该返回-7吧。<br>4，等等，如果list里面有重复项呢？{7,9,8,9}应该只返回一个9就可以了<br>5，那么，如果list里面只有一个元素呢？{9}当然是返回9了<br>6，考虑完了？空值呢？如果list为空，{ }要怎么处理呢？<br>总结：1+2+5-&gt;注意上下界；3-&gt;max的初始值应为一个数型最小值；4-&gt;记录且return一个max；6-&gt;抛个异常<br>代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//Largest.java</span><br><span class="line">public class Largest &#123;</span><br><span class="line">	public static int largest (int[] list) &#123;</span><br><span class="line">		int max=Integer.MIN_VALUE;</span><br><span class="line">		if(list.length == 0) &#123;</span><br><span class="line">			throw new RuntimeException(&quot;Empty list&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		for(int i=0;i&lt;list.length;i++) &#123;</span><br><span class="line">			if(list[i]&gt;max) &#123;</span><br><span class="line">				max = list[i];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		return max;	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>事实上上述代码的测试代码就是考虑了最开始那6个测试例子，加以实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">//LargestTest.java</span><br><span class="line">import junit.framework.*;</span><br><span class="line">public class LargestTest extends TestCase &#123;</span><br><span class="line">	public LargestTest(String name) &#123;</span><br><span class="line">		super(name);</span><br><span class="line">	&#125;</span><br><span class="line">	//test numbers</span><br><span class="line">	public void testNums() &#123;</span><br><span class="line">		//general test</span><br><span class="line">		assertEquals(9, Largest.largest(new int[] &#123;7,8,9&#125;));</span><br><span class="line">		//order test</span><br><span class="line">		assertEquals(9, Largest.largest(new int[] &#123;7,9,8&#125;));</span><br><span class="line">		assertEquals(9, Largest.largest(new int[] &#123;9,8,7&#125;));</span><br><span class="line">		//repetition test</span><br><span class="line">		assertEquals(9, Largest.largest(new int[] &#123;7,9,8,9&#125;));</span><br><span class="line">		//single test</span><br><span class="line">		assertEquals(9, Largest.largest(new int[] &#123;9&#125;));</span><br><span class="line">		//negative test</span><br><span class="line">		assertEquals(-7, Largest.largest(new int[] &#123;-7,-8,-9&#125;));</span><br><span class="line">	&#125;</span><br><span class="line">	//test empty</span><br><span class="line">	public void testisEmpty() &#123;</span><br><span class="line">		try &#123;</span><br><span class="line">			Largest.largest(new int[] &#123;&#125;);</span><br><span class="line">			fail(&quot;An exception should been thrown!&quot;);</span><br><span class="line">		&#125;catch(RuntimeException e) &#123;</span><br><span class="line">			assertTrue(true);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注：1，如果import junit.framework.*;报错是因为没有导入junit的jar包。可以Eclipse中：右键工程名–&gt;属性–&gt;Java Build Path–&gt;Libraries–&gt;Add Library，选中JUnit导入，版本随意。<br>2，相关代码可以直接在我的<a href="https://github.com/wtligit/Unit-Test" target="_blank" rel="noopener">Github</a>下载，欢迎star。</p>
<p>做一个简单的总结，测试代码必须要做以下几件事：<br>1，准备测试所需要的各种条件（创建所有必须的对象，分配必要的资源等等）<br>2，调用要测试的方法<br>3，验证被测试方法的行为和期望是否一致<br>4，完成后清理各种资源（第三章讲）</p>
<h2 id="JUnit-测试骨架"><a href="#JUnit-测试骨架" class="headerlink" title="JUnit 测试骨架"></a>JUnit 测试骨架</h2><p>下面是一段简单的测试代码，它展示了让一段断言方法所需要的骨架的最小要求<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import junit.framework.*;</span><br><span class="line">public class FrameTest extends TestCase &#123;</span><br><span class="line">	public FrameTest(String name) &#123;</span><br><span class="line">		super(name);</span><br><span class="line">	&#125;</span><br><span class="line">	public void testFrame()&#123;</span><br><span class="line">	    ...</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>尽管上面的代码非常简洁，还是要简单解释下每一部分<br>1，首先，第一行的import声明引入了必需的JUnit类。<br>2，接下来在第2行定义了一个类：每个包含测试的类都必须如上所示那样有TestCase继承而来。基类TestCase提供了我们所需的大部分单元测试功能，包括所有在前面讲述过的断言方法。<br>3，其中，基类需要一个以String为参数的构造函数，因而我们必须调用super来传递这么一个名字。我们不知道这个名字此时是什么，因而我们就仅仅让我们自己的构造函数接受String参数并把这个参数在第4行传递上去。<br>4，最后，测试类包含了名为test的方法。在上面这个例子中，我们在第6行写了一个名为testFrame的方法。而所有以test开头的方法都会被JUnit自动运行。当然，还可以通过定义suite方法制定特殊的函数来运行（第三章讲）。</p>
<p>在下一章<a href="http://wtli.top/2018/01/29/UT-constitute/" target="_blank" rel="noopener">单元测试整理（三）——JUnit 测试组成和注释</a>将进一步展示更完整的JUnit骨架，介绍一些复杂一点的辅助测试方法。</p>
</div><div class="tags"></div><div class="post-nav"><a class="pre" href="/2018/01/29/UT-constitute/">单元测试整理（三）——JUnit 测试组成和注释</a><a class="next" href="/2018/01/29/latexdiff/">latexdiff的使用和配置</a></div><div id="disqus_thread"><div class="btn_click_load"><button class="disqus_click_btn">阅读评论 「请确保 disqus.com 可以正常加载」</button></div><script>var disqus_shortname = 'wtli';
var disqus_identifier = '2018/01/29/UT-assert/';
var disqus_title = '单元测试整理（二）——断言篇，首个单元测试程序';
var disqus_url = 'http://yoursite.com/2018/01/29/UT-assert/';
$('.btn_click_load').click(function() {
  (function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
  $('.btn_click_load').css('display','none');
});
$.ajax({
  url: 'https://disqus.com/next/config.json',
  timeout: 3000,
  type: 'GET',
  success: (function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    $('.btn_click_load').css('display','none');
  })(),
  error: function() {
    $('.btn_click_load').css('display','block');
  }
});</script><script id="dsq-count-scr" src="//wtli.disqus.com/count.js" async></script></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://yoursite.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/03/17/queueStack/">队列与栈的基本操作</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/03/16/treeConstruct/">树的重建</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/03/16/LCS/">LCS</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/03/15/treeTraverse/">二叉树的四种遍历</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/03/12/C++/">C++知识汇总</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/03/11/Sort/">数据结构中十种经典排序方法汇总(C++)</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/03/10/Datastructure/">数据结构知识整理</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/02/26/VLOOKUP/">Excel怎样把相同列数据合并到一行</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/02/02/Interview/">面试知识整理</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/01/30/UT-easymock/">单元测试整理（六）—— 使用EasyMock和JUnit进行单元测试</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-comment-o"> 最近评论</i></div><script type="text/javascript" src="//wtli.disqus.com/recent_comments_widget.js?num_items=5&amp;hide_avatars=1&amp;avatar_size=32&amp;excerpt_length=20&amp;hide_mods=1"></script></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://github.com/wtligit" title="GitHub" target="_blank">GitHub</a><ul></ul><a href="http://blog.csdn.net/potatostyles" title="CSDN" target="_blank">CSDN</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">Page of Wentao Li.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.2.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.2.5/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>