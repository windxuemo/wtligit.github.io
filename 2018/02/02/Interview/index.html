<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>面试知识整理 | Page of Wentao Li</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/7.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">面试知识整理</h1><a id="logo" href="/.">Page of Wentao Li</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">面试知识整理</h1><div class="post-meta">Feb 2, 2018</div><a class="disqus-comment-count" data-disqus-identifier="2018/02/02/Interview/" href="/2018/02/02/Interview/#disqus_thread"></a><div class="post-content"><h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><h3 id="并发和并行"><a href="#并发和并行" class="headerlink" title="并发和并行"></a>并发和并行</h3><ul>
<li>你吃饭吃到一半，电话来了，你一直到吃完了以后才去接，这就说明你不支持并发也不支持并行。</li>
<li>你吃饭吃到一半，电话来了，你停了下来接了电话，接完后继续吃饭，这说明你支持并发。</li>
<li>你吃饭吃到一半，电话来了，你一边打电话一边吃饭，这说明你支持并行。</li>
<li>并发的关键是你有处理多个任务的能力，不一定要同时。并行的关键是你有同时处理多个任务的能力。</li>
</ul>
<h3 id="操作系统的设计可以归结为三点"><a href="#操作系统的设计可以归结为三点" class="headerlink" title="操作系统的设计可以归结为三点"></a>操作系统的设计可以归结为三点</h3><ul>
<li>以多进程形式，允许多个任务同时运行；</li>
<li>以多线程形式，允许单个任务分成不同的部分运行；</li>
<li>提供协调机制，一方面防止进程之间和线程之间产生冲突，另一方面允许进程之间和线程之间共享资源</li>
</ul>
<h3 id="请分别简单说一说程序、进程和线程以及它们的区别？"><a href="#请分别简单说一说程序、进程和线程以及它们的区别？" class="headerlink" title="请分别简单说一说程序、进程和线程以及它们的区别？"></a>请分别简单说一说程序、进程和线程以及它们的区别？</h3><ul>
<li>进程是具有一定功能的程序关于某个数据集合上的一次运行活动，进程是系统进行资源调度和分配的一个独立单位。</li>
<li>线程是进程的实体，是CPU调度和分派的基本单位，它是比进程更小的能独立运行的基本单位。</li>
<li>一个进程可以有多个线程，多个线程也可以并发执行</li>
<li>程序：计算机指令的集合，它以文件的形式存储在磁盘上。程序是静态实体（passive Entity），在多道程序系统中，它是不能独立运行的，更不能与其他程序并发执行。使用系统资源情况：不使用（程序不能申请系统资源，不能被系统调度，也不能作为独立运行的单位，它不占用系统的运行资源）。</li>
</ul>
<h3 id="线程同步的方式有哪些？"><a href="#线程同步的方式有哪些？" class="headerlink" title="线程同步的方式有哪些？"></a>线程同步的方式有哪些？</h3><ul>
<li>互斥量：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问。</li>
<li>信号量：它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量。</li>
<li>事件（信号）：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作。</li>
</ul>
<h3 id="进程同步有哪几种机制？"><a href="#进程同步有哪几种机制？" class="headerlink" title="进程同步有哪几种机制？"></a>进程同步有哪几种机制？</h3><ul>
<li>原子操作、信号量机制、自旋锁管程、会合、分布式系统</li>
</ul>
<h3 id="进程的通信方式有哪些"><a href="#进程的通信方式有哪些" class="headerlink" title="进程的通信方式有哪些"></a>进程的通信方式有哪些</h3><ul>
<li>主要分为：管道、系统IPC（包括消息队列、信号量、共享存储）、SOCKET</li>
<li>管道主要分为：普通管道PIPE 、流管道（s_pipe）、命名管道（name_pipe）</li>
<li>管道是一种半双工的通信方式，数据只能单项流动，并且只能在具有亲缘关系的进程间流动，进程的亲缘关系通常是父子进程</li>
<li>命名管道也是半双工的通信方式，它允许无亲缘关系的进程间进行通信</li>
<li>信号量是一个计数器，用来控制多个进程对资源的访问，它通常作为一种锁机制。</li>
<li>消息队列是消息的链表，存放在内核中并由消息队列标识符标识。</li>
<li>信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。</li>
<li>共享内存就是映射一段能被其它进程访问的内存，这段共享内存由一个进程创建，但是多个进程可以访问。</li>
</ul>
<h3 id="什么是死锁？死锁产生的条件？"><a href="#什么是死锁？死锁产生的条件？" class="headerlink" title="什么是死锁？死锁产生的条件？"></a>什么是死锁？死锁产生的条件？</h3><ul>
<li>在两个或者多个并发进程中，如果每个进程持有某种资源而又等待其它进程释放它或它们现在保持着的资源，在未改变这种状态之前都不能向前推进，称这一组进程产生了死锁。通俗的讲就是两个或多个进程无限期的阻塞、相互等待的一种状态。</li>
<li>死锁产生的四个条件（有一个条件不成立，则不会产生死锁）</li>
<li>互斥条件：一个资源一次只能被一个进程使用</li>
<li>请求与保持条件：一个进程因请求资源而阻塞时，对已获得资源保持不放</li>
<li>不剥夺条件：进程获得的资源，在未完全使用完之前，不能强行剥夺</li>
<li>循环等待条件：若干进程之间形成一种头尾相接的环形等待资源关系</li>
</ul>
<h3 id="解决死锁的方法分为死锁的预防，避免，检测与恢复三种"><a href="#解决死锁的方法分为死锁的预防，避免，检测与恢复三种" class="headerlink" title="解决死锁的方法分为死锁的预防，避免，检测与恢复三种"></a>解决死锁的方法分为死锁的预防，避免，检测与恢复三种</h3><ul>
<li>死锁的预防是保证系统不进入死锁状态的一种策略。它的基本思想是要求进程申请资源时遵循某种协议，从而打破产生死锁的四个必要条件中的一个或几个，保证系统不会进入死锁状态。</li>
<li>死锁的避免，它不限制进程有关申请资源的命令，而是对进程所发出的每一个申请资源命令加以动态地检查，并根据检查结果决定是否进行资源分配。就是说，在资源分配过程中若预测有发生死锁的可能性，则加以避免。这种方法的关键是确定资源分配的安全性。银行家算法，著名的避免死锁的算法。</li>
<li>死锁检测与恢复是指系统设有专门的机构，当死锁发生时，该机构能够检测到死锁发生的位置和原因，并能通过外力破坏死锁发生的必要条件，从而使得并发进程从死锁状态中恢复出来</li>
</ul>
<h3 id="进程有哪几种状态？"><a href="#进程有哪几种状态？" class="headerlink" title="进程有哪几种状态？"></a>进程有哪几种状态？</h3><ul>
<li>就绪状态：进程已获得除处理机以外的所需资源，等待分配处理机资源</li>
<li>运行状态：占用处理机资源运行，处于此状态的进程数小于等于CPU数</li>
<li>阻塞状态： 进程等待某种条件，在条件满足之前无法执行 </li>
</ul>
<h3 id="分页和分段有什么区别？"><a href="#分页和分段有什么区别？" class="headerlink" title="分页和分段有什么区别？"></a>分页和分段有什么区别？</h3><ul>
<li>段是信息的逻辑单位，它是根据用户的需要划分的，因此段对用户是可见的；页是信息的物理单位，是为了管理主存的方便而划分的，对用户是透明的。</li>
<li>段的大小不固定，有它所完成的功能决定；页大大小固定，由系统决定</li>
<li>段向用户提供二维地址空间；页向用户提供的是一维地址空间</li>
<li>段是信息的逻辑单位，便于存储保护和信息的共享，页的保护和共享受到限制。</li>
</ul>
<h3 id="操作系统中进程调度策略有哪几种？"><a href="#操作系统中进程调度策略有哪几种？" class="headerlink" title="操作系统中进程调度策略有哪几种？"></a>操作系统中进程调度策略有哪几种？</h3><ul>
<li>FCFS(先来先服务)，优先级，时间片轮转，多级反馈</li>
</ul>
<h3 id="描述多道批处理、分时、实时操作系统的特点各是什么？"><a href="#描述多道批处理、分时、实时操作系统的特点各是什么？" class="headerlink" title="描述多道批处理、分时、实时操作系统的特点各是什么？"></a>描述多道批处理、分时、实时操作系统的特点各是什么？</h3><ul>
<li>批处理操作系统：多道性、无序性、调度性，系统利用率高、吞吐量大、平均周转时间长、但无交互能力。</li>
<li>分时操作系统：有多路性、独立性、及时性和交互性。 有较好的人机交互的特性，并且可以实现共享主机</li>
<li>实时系统：有多路性、独立性、及时性、交互性和可靠性。实际上是指操作系统工作时，其各种资源可以根据需要随时进行动态分配。由于各种资源可以进行动态分配，因此，其处理事务的能力较强、速度较快。</li>
<li>总结：从可靠性：实时系统更强，从交互性：分时系统更强。</li>
</ul>
<h3 id="进程控制块PCB的作用"><a href="#进程控制块PCB的作用" class="headerlink" title="进程控制块PCB的作用"></a>进程控制块PCB的作用</h3><ul>
<li>作为独立运行基本单位的标志</li>
<li>能实现间断性运行方式</li>
<li>提供进程通信管理所需要的信息</li>
<li>提供进程调度所需要的信息</li>
</ul>
<h3 id="什么是临界区？如何解决冲突？"><a href="#什么是临界区？如何解决冲突？" class="headerlink" title="什么是临界区？如何解决冲突？"></a>什么是临界区？如何解决冲突？</h3><ul>
<li>每个进程中访问临界资源的那段程序称为临界区，每次只准许一个进程进入临界区，进入后不允许其他进程进入。</li>
<li>如果有若干进程要求进入空闲的临界区，一次仅允许一个进程进入；</li>
<li>任何时候，处于临界区内的进程不可多于一个。如已有进程进入自己的临界区，则其它所有试图进入临界区的进程必须等待；</li>
<li>进入临界区的进程要在有限时间内退出，以便其它进程能及时进入自己的临界区；</li>
<li>如果进程不能进入自己的临界区，则应让出CPU，避免进程出现“忙等”现象。</li>
</ul>
<h3 id="Windows下的内存是如何管理的？"><a href="#Windows下的内存是如何管理的？" class="headerlink" title="Windows下的内存是如何管理的？"></a>Windows下的内存是如何管理的？</h3><p>Windows提供了3种方法来进行内存管理：</p>
<ul>
<li>虚拟内存，最适合用来管理大型对象或者结构数组；</li>
<li>内存映射文件，最适合用来管理大型数据流（通常来自文件）以及在单个计算机上运行多个进程之间共享数据；</li>
<li>内存堆栈，最适合用来管理大量的小对象。</li>
<li>Windows操纵内存可以分两个层面：物理内存和虚拟内存。其中物理内存由系统管理，不允许应用程序直接访问</li>
</ul>
<h3 id="操作系统的内容分为几块？什么叫做虚拟内存？他和主存的关系如何？内存管理属于操作系统的内容吗？"><a href="#操作系统的内容分为几块？什么叫做虚拟内存？他和主存的关系如何？内存管理属于操作系统的内容吗？" class="headerlink" title="操作系统的内容分为几块？什么叫做虚拟内存？他和主存的关系如何？内存管理属于操作系统的内容吗？"></a>操作系统的内容分为几块？什么叫做虚拟内存？他和主存的关系如何？内存管理属于操作系统的内容吗？</h3><ul>
<li>操作系统的主要组成部分：进程和线程的管理，存储管理，设备管理，文件管理。</li>
<li>虚拟内存是一些系统页文件，存放在磁盘上，每个系统页文件大小为4K，物理内存也被分页，每个页大小也为4K，这样虚拟页文件和物理内存页就可以对应，实际上虚拟内存就是用于物理内存的临时存放的磁盘空间。</li>
<li>页文件就是内存页， 物理内存中每页叫物理页，磁盘上的页文件叫虚拟页，物理页+虚拟页就是系统所有使用的页文件的总和。</li>
</ul>
<h3 id="虚拟存储器页面置换算法"><a href="#虚拟存储器页面置换算法" class="headerlink" title="虚拟存储器页面置换算法"></a>虚拟存储器页面置换算法</h3><ul>
<li>最佳置换算法（Optimal）：一种理论的算法，选着淘汰的页面是以后一定不再使用的页面（理想化的），该算法无法实现，只能作为其他算法好坏的一个评价对比。</li>
<li>先进先出（FIFO）算法：总是最先淘汰最先进去的页面，该算法容易实现。缺点：通常程序调入内存的先后顺序和程序执行的先后顺序不一致，导致缺页率高。</li>
<li>最近最久未使用（LRU）：FIFO算法性能差，LRU算法根据页面调入内存的先后顺序决定，因为违法预测未来的使用情况，就是用过去的使用情况作为将来的使用情况的近似。</li>
<li>最少使用算法（LFU）：在每个页面设置一个移位寄存器记录该页面的访问频率，最近时期最少使用的页面被淘汰</li>
</ul>
<h3 id="外存的组织方式"><a href="#外存的组织方式" class="headerlink" title="外存的组织方式"></a>外存的组织方式</h3><ul>
<li>连续组织方式，<pre><code>又称为连续分配方式，要求每一个文件分配一个相邻的盘快
优点：顺序访问容易：访问连续文件非常容易，访问速度非常快
缺点：要求为文件分配连续的空间，必须事先知道文件的长度，不能灵活的删除插入记录动态增长的文件难分配空间
</code></pre></li>
<li>链接组织方式（分为隐式链接和显示链接）<pre><code>采用链接组织的方式可以为文件分配多个不连续的盘快
</code></pre>　　　     优点：1：消除磁盘的外部碎片，提高内存的利用率。<br>　　　           2：对插入删除修改非常容易。<br>　　　           3：可以适应文件的动态增长</li>
<li>索引组织方式<br>　　　分为单索引和多索引组织方式。
　　　<h3 id="linux的文件系统"><a href="#linux的文件系统" class="headerlink" title="linux的文件系统"></a>linux的文件系统</h3></li>
<li>linux的文件系统是采用层级式的树状目录结构，在此结构中的最上层是根目录“/”，然后在此目录下再创建其他的目录，深刻理解linux文件目录是非常重要的</li>
<li>root，存放root用户的相关文件 </li>
<li>home，存放普通用户的相关文件 </li>
<li>bin，存放常用命令的目录，如vi，su </li>
<li>sbin，要具有一定权限才可以使用命令 </li>
<li>mnt，默认挂载光驱和软驱的目录 </li>
<li>etc，存放配置的相关文件 </li>
<li>var，存放经常变化的文件，如网络连接的sock文件 </li>
<li>boot，存放引导系统启动的相关文件 </li>
<li>usr，安装一个软件的默认目录，相当于windows下的program files
　　　<h3 id="常考点总结"><a href="#常考点总结" class="headerlink" title="常考点总结"></a>常考点总结</h3>1、进程是并发过程中程序的执行过程</li>
</ul>
<p>2、进程的特征：结构特征动态性并发性独立性异步性</p>
<p>3、临界区指在每个进程中访问临界资源的那段代码（一次仅允许一个进程使用的资源称为临界资源）</p>
<p>4，现在操作系统中申请资源的基本单位是进程，在CPU得到执行的基本单位是线程，进程是由程序段、数据段、PCB组成的</p>
<p>5，对临界资源应采取互斥访问方式来实现共享</p>
<p>6，P.V操作是一种低级进程通信原语</p>
<p>7，对于记录性信号量，在执行一次P操作时，信号量的值应当减1，当其值为小于0时进程应阻塞；在执行V操作时，信号量的值应当加1；当其值小于等于0时，应唤醒阻塞队列中的进程。</p>
<p>8，N个进程共享某一临界资源，（n-1）~1</p>
<p>9，短作业优先算法，T1&lt;T2&lt;T3平均周转时间为：T1+2XT2/3+T3/3</p>
<p>10，响应比Rp=（等待时间+要求服务时间）/要求服务器时间=响应时间/要求服务时间</p>
<p>11思索是指多个进程在运行过程中因争夺资源，而造成的一种僵局，当进程处于这种僵局状态时，若无外力作用，他们都将无法再向前推进。</p>
<p>死锁的避免是根据防止系统进入不安全状态。</p>
<p>产生死锁的根本原因是资源分配不当和资源数量不足，发生死锁的四个必要条件是：互斥条件，请求和保持条件，不剥夺条件和环路等待条件，银行家算法用于避免死锁</p>
<p>12，如果系统中有N个进程，最多为（N-1）个</p>
<p>13，若系统采用轮转法调度进程系统采用的是剥夺式调度</p>
<p>14，既考虑作业等待时间，又考虑作业执行时间，的调度算法是响应比优先调度算法</p>
<p>15，资源的有序分配策略可以破坏死锁的“循环等待”</p>
<p>16，并非所有的不安全状态都必然会转为死锁状态，但当系统进图不安全按状态后变有可能进入死锁状态，</p>
<p>17，重定位：在作业地址空间中使用的逻辑地址变为内存物理地址</p>
<p>18，支持程序放在不连续内存中储存管理方法有分取式分配，分段式分配，段页式分配页式存储主要特点是不要将作业同时全部装入到主存的的连续区域</p>
<p>19，适合多道程序运行的存储管理中，存储保护是为了防止各道作业的相互干扰</p>
<p>20，采用页式存储管理时，重定位的工作由地址转换机</p>
<p>21，段页式存储管理中的地址映像表是每个作业或进程一张段表，每个段一张页表</p>
<p>22，在虚拟页式存储管理方案中，完成将页面调入内存的工作的是缺页中断处理</p>
<p>23，分段管理和分页管理的主要区别是分页管理有存储保护，分段管理没有</p>
<p>24，在股低估分区分配中，可以不同但预先固定的</p>
<p>25，不使用中断机构的I/O控制方式是程序I/O方式</p>
<p>26，spooling技术能独占设备改造成可以共享的虚拟设备  </p>
<p>27，磁盘防伪中把数据从磁盘读出，叫做传输时间</p>
<p>28，共享设备指同一时间内运行多个进程同时访问的设备</p>
<p>29，通过软件的功能扩充，把原来独占的设备爱造成若干个可共享的设备，虚拟设备</p>
<p>30，DMA方式如果I/O设备不通过CPU来完成</p>
<p>31，设备独立性用户程序独立于具体物理设备的一种特性</p>
<p>32，虚拟设备一个物理设备变换成多个对应的逻辑设备</p>
<p>33，通道是一种特殊的处理机，通道按传递数据的方式分为：字节多路通道，数组选择通道，数组多路通道</p>
<p>通道涉及的数据结构是设备控制器，控制器控制块，通道控制块，系统设备表</p>
<p>34，磁盘高速缓冲设在内存中，目的是提高I/O磁盘速度</p>
<p>35，磁盘空间的地址有盘面号，柱面号，扇区号组成。访问磁盘的时间有 寻道时间，旋转等待时间，读写时间 </p>
<p>36，将系统段用参数翻译成设备操作命令的工作由设备无关的操作系统完成</p>
<p>37，向设备寄存器写入控制命令由设备驱动程序完成</p>
<p>38，寻找设备驱动程序由设备无关的操作系统软件完成</p>
<p>39，设备管理的功能是设备分配，缓冲区管理和实现物理I/O设备的操作</p>
<p>40，根据设备的固有属性特点，设备可分为独占设备，共享设备和虚拟设备</p>
<p>41，引入缓冲区技术可提高处理器执行程序和设备的输入输出操作的并行程序文件管理</p>
<p>42，物理文件的组织方式是由操作系统确定的，文件的顺序存取是按文件的逻辑号逐一存取</p>
<p>43，系统通过树形目录结构来解决重名问题</p>
<p>44，在UNIX操作系统中，把输入输出设备看做特殊文件</p>
<p>45，打开文件操作的主要工作是把指定的目录复制到内存指定区域</p>
<p>46，文件路径名是指从根目录到该文件所经历的路径中各符号名的集合</p>
<p>47，按逻辑结构划分，文件主要有两类：记录是文件，流式文件，文件系统的主要目的是实现对文件的按名存取</p>
<p>48连续结构文件必须采用连续分配方式，而链接结构文件和索引结构文件都可采取离散分配方式</p>
<p>49，文件系统中，若文件的物理结构采用连续结构有关文件的物理位置的信息包括首块地址和文件长度</p>
<p>50，位示图可用于磁盘空间管理，在文件系统中，为实现文件保护，一般采用口令，密码和访问控制  </p>
<p>1、进程是具有独立功能程序在某个数据集合上的一次执行过程。线程是进程内的一个执行实体或执行单元。</p>
<p>进程和线程的区别：</p>
<p>（a）不同进程的地址空间是独立的，而同一进程内的线程共享同一地址空间。一个进程的线程在另一个进程内是不可见的。</p>
<p>（b） 在引入线程的操作系统中，进程是资源分配和调度的单位，线程是处理机调度和分配的单位，资源是分配给进程的，线程只拥有很少资源，因而切换代价比进程切换低。</p>
<p>2、死锁在多道程序系统中，当一组进程中的每个进程均无限期地等待被改组进程中的另一进程所占有且永远不会释放的资源，此时的系统处于死锁状态。</p>
<p>死锁产生的原因：</p>
<p>（a）系统提供的资源有限；</p>
<p>（b）进程推进顺序不当。</p>
<p>产生死锁的必要条件：互斥条件、不可剥夺条件、请求和保持条件、循环等待条件</p>
<p>3、执行如下访问页号序列： 1，2，3，4，1，2，5，1，2，3，4，5 试说明采用先进（1）FIFO: 9次（2）LRU：10次 （3）OPT：7次   </p>
<p>4、什么是操作系统的基本功能?</p>
<p>1.处理机管理。在多道程序或多用户的情况下，要组织多个作业同时运行，就要解决对处理机分配调度策略、分配实施和资源回收等问题。</p>
<p>2.存储管理。存储管理的主要工作是对内部存储器进行分配、保护和扩充和管理。</p>
<p>3.设备管理。涉及到通道、控制器、输入输出设备的分配和管理以及设备独立性。</p>
<p>4.信息管理(文件系统管理) 是对系统的软件资源的管理。</p>
<p>5.用户接口。操作系统还为用户提供一个友好的用户接口。一般来说，操作系统提供两种方式的接口来为用户服务。</p>
<p>5、分级调度分为4级：</p>
<p>(1) 作业调度</p>
<p>(2) 交换调度</p>
<p>(3) 进程调度 </p>
<p>(4) 线程调度。</p>
<p>6、试写出程序与进程的区别</p>
<p>（1）进程是一个动态概念，而程序是一个静态概念。</p>
<p>（2）进程具有并行特征，而程序不反映执行所以没有并行特征</p>
<p>（3）进程是竞争计算机系统资源的基本单位，而程序不反映执行也就不会竞争计算机系统资源</p>
<p>（4）不同的进程可以包含同一程序，只要该程序所对应的数据集不同。 </p>
<p>7、页式管理的基本原理是什么?</p>
<p>（1）进程的虚拟空间被划分成长度相等的页。</p>
<p>（2）内存空间也按页的大小划分成长度相等的页面。</p>
<p>（3）采用请求调页或预调技术实现内外存储器的统一管理。</p>
<p>8、进程调度有哪些功能?</p>
<p>（1）记录系统中所有进程的执行情况。</p>
<p>（2）选择占有处理机的进程</p>
<p>（3）进行进程上下文切换</p>
<p>9、批处理操作系统、分时操作系统和实时操作系统的特点各是什么？</p>
<p>(1) 批处理操作系统的特点：成批处理，系统吞吐量高，资源利用率高，用户不能直接干预作业的执行。</p>
<p>(2)分时操作系统的特点：多路性、独立性、及时性、交互性。</p>
<p>(3)实时操作系统的特点：及时响应、快速处理；高可靠性和安全性；不要求系统资源利用率。</p>
<p>10、Windows下的内存是如何管理的？</p>
<p>　　Windows提供了3种方法来进行内存管理：虚拟内存，最适合用来管理大型对象或者结构数组；内存映射文件，最适合用来管理大型数据流（通常来自文件）以及在单个计算机上运行多个进程之间共享数据；内存堆栈，最适合用来管理大量的小对象。</p>
<p>　　Windows操纵内存可以分两个层面：物理内存和虚拟内存。</p>
<p>　　其中物理内存由系统管理，不允许应用程序直接访问，应用程序可见的只有一个2G地址空间，而内存分配是通过堆进行的。对于每个进程都有自己的默认堆，当一个堆创建后，就通过虚拟内存操作保留了相应大小的地址块（不占有实际的内存，系统消耗很小）。当在堆上分配一块内存时，系统在堆的地址表里找到一个空闲块（如果找不到，且堆创建属性是可扩充的，则扩充堆大小），为这个空闲块所包含的所有内存页提交物理对象（在物理内存上或硬盘的交换文件上），这时就可以访问这部分地址。提交时，系统将对所有进程的内存统一调配，如果物理内存不够，系统试图把一部分进程暂时不访问的页放入交换文件，以腾出部分物理内存。释放内存时，只在堆中将所在的页解除提交（相应的物理对象被解除），继续保留地址空间。</p>
<p>　　如果要知道某个地址是否被占用/可不可以访问，只要查询此地址的虚拟内存状态即可。如果是提交，则可以访问。如果仅仅保留，或没保留，则产生一个软件异常。此外，有些内存页可以设置各种属性。如果是只读，向内存写也会产生软件异常。</p>
<p>11、Windows消息调度机制是（C）</p>
<p>　　A）指令队列；B）指令堆栈；C）消息队列；D）消息堆栈</p>
<p>解析：</p>
<p>　　处理消息队列的顺序。首先Windows绝对不是按队列先进先出的次序来处理的，而是有一定优先级的。优先级通过消息队列的状态标志来实现的。首先，最高优先级的是别的线程发过来的消息（通过sendmessage）；其次，处理登记消息队列消息；再次处理QS_QUIT标志，处理虚拟输入队列，处理wm_paint；最后是wm_timer。</p>
<p>12、描述实时系统的基本特性</p>
<p>　　在特定时间内完成特定的任务，实时性与可靠性。</p>
<p>　　所谓“实时操作系统”，实际上是指操作系统工作时，其各种资源可以根据需要随时进行动态分配。由于各种资源可以进行动态分配，因此，其处理事务的能力较强、速度较快。</p>
<p>13、中断和轮询的特点</p>
<p>　　对I/O设备的程序轮询的方式，是早期的计算机系统对I/O设备的一种管理方式。它定时对各种设备轮流询问一遍有无处理要求。轮流询问之后，有要求的，则加以处理。在处理I/O设备的要求之后，处理机返回继续工作。尽管轮询需要时间，但轮询要比I/O设备的速度要快得多，所以一般不会发生不能及时处理的问题。当然，再快的处理机，能处理的输入输出设备的数量也是有一定限度的。而且，程序轮询毕竟占据了CPU相当一部分处理时间，因此，程序轮询是一种效率较低的方式，在现代计算机系统中已很少应用。</p>
<p>　　程序中断通常简称中断，是指CPU在正常运行程序的过程中，由于预先安排或发生了各种随机的内部或外部事件，使CPU中断正在运行的程序，而转到为响应的服务程序去处理。</p>
<p>　　轮询——效率低，等待时间很长，CPU利用率不高。</p>
<p>　　中断——容易遗漏一些问题，CPU利用率高。</p>
<p>14、什么是临界区？如何解决冲突？</p>
<p>　　每个进程中访问临界资源的那段程序称为临界区，每次只准许一个进程进入临界区，进入后不允许其他进程进入。</p>
<p>　　（1）如果有若干进程要求进入空闲的临界区，一次仅允许一个进程进入；</p>
<p>　　（2）任何时候，处于临界区内的进程不可多于一个。如已有进程进入自己的临界区，则其它所有试图进入临界区的进程必须等待；</p>
<p>　　（3）进入临界区的进程要在有限时间内退出，以便其它进程能及时进入自己的临界区；</p>
<p>　　（4）如果进程不能进入自己的临界区，则应让出CPU，避免进程出现“忙等”现象。</p>
<p>15、说说分段和分页</p>
<p>　　页是信息的物理单位，分页是为实现离散分配方式，以消减内存的外零头，提高内存的利用率；或者说，分页仅仅是由于系统管理的需要，而不是用户的需要。</p>
<p>　　段是信息的逻辑单位，它含有一组其意义相对完整的信息。分段的目的是为了能更好的满足用户的需要。</p>
<p>　　页的大小固定且由系统确定，把逻辑地址划分为页号和页内地址两部分，是由机器硬件实现的，因而一个系统只能有一种大小的页面。段的长度却不固定，决定于用户所编写的程序，通常由编辑程序在对源程序进行编辑时，根据信息的性质来划分。</p>
<p>　　分页的作业地址空间是一维的，即单一的线性空间，程序员只须利用一个记忆符，即可表示一地址。分段的作业地址空间是二维的，程序员在标识一个地址时，既需给出段名，又需给出段内地址。</p>
<p>16、说出你所知道的保持进程同步的方法？</p>
<p>　　进程间同步的主要方法有原子操作、信号量机制、自旋锁、管程、会合、分布式系统等。</p>
<p>17、Linux中常用到的命令</p>
<p>　　显示文件目录命令ls        如ls</p>
<p>　　改变当前目录命令cd        如cd /home</p>
<p>　　建立子目录mkdir           如mkdir xiong</p>
<p>　　删除子目录命令rmdir       如rmdir /mnt/cdrom</p>
<p>　　删除文件命令rm            如rm /ucdos.bat</p>
<p>　　文件复制命令cp            如cp /ucdos /fox</p>
<p>　　获取帮助信息命令man      如man ls</p>
<p>　　显示文件的内容less        如less mwm.lx</p>
<p>　　重定向与管道type          如type readme&gt;&gt;direct，将文件readme的内容追加到文direct中</p>
<p>18、Linux文件属性有哪些？（共十位）</p>
<p>　　-rw-r–r–那个是权限符号，总共是- — — —这几个位。</p>
<p>　　第一个短横处是文件类型识别符：-表示普通文件；c表示字符设备（character）；b表示块设备（block）；d表示目录（directory）；l表示链接文件（link）；后面第一个三个连续的短横是用户权限位（User），第二个三个连续短横是组权限位（Group），第三个三个连续短横是其他权限位（Other）。每个权限位有三个权限，r（读权限），w（写权限），x（执行权限）。如果每个权限位都有权限存在，那么满权限的情况就是：-rwxrwxrwx；权限为空的情况就是- — — —。</p>
<p>　　权限的设定可以用chmod命令，其格式位：chmod ugoa+/-/=rwx filename/directory。例如：</p>
<p>　　一个文件aaa具有完全空的权限- — — —。</p>
<p>　　chmod u+rw aaa（给用户权限位设置读写权限，其权限表示为：- rw- — —）</p>
<p>　　chmod g+r aaa（给组设置权限为可读，其权限表示为：- — r– —）</p>
<p>　　chmod ugo+rw aaa（给用户，组，其它用户或组设置权限为读写，权限表示为：- rw- rw- rw-）</p>
<p>　　如果aaa具有满权限- rwx rwx rwx。</p>
<p>　　chmod u-x aaa（去掉用户可执行权限，权限表示为：- rw- rwx rwx）</p>
<p>　　如果要给aaa赋予制定权限- rwx r-x r-x，命令为：</p>
<p>　　chmod u=rwx，go=rx aaa</p>
<p>19、简术OSI的物理层Layer1，链路层Layer2，网络层Layer3的任务。</p>
<p>　　网络层：通过路由选择算法，为报文或分组通过通信子网选择最适当的路径。</p>
<p>　　链路层：通过各种控制协议，将有差错的物理信道变为无差错的、能可靠传输数据帧的数据链路。</p>
<p>　　物理层：利用传输介质为数据链路层提供物理连接，实现比特流的透明传输。</p>
<p>20、什么是中断？中断时CPU做什么工作？</p>
<p>　　中断是指在计算机执行期间，系统内发生任何非寻常的或非预期的急需处理事件，使得CPU暂时中断当前正在执行的程序而转去执行相应的事件处理程序。待处理完毕后又返回原来被中断处继续执行或调度新的进程执行的过程。</p>
<p>21、你知道操作系统的内容分为几块吗？什么叫做虚拟内存？他和主存的关系如何？内存管理属于操作系统的内容吗？</p>
<p>　　操作系统的主要组成部分：进程和线程的管理，存储管理，设备管理，文件管理。虚拟内存是一些系统页文件，存放在磁盘上，每个系统页文件大小为4K，物理内存也被分页，每个页大小也为4K，这样虚拟页文件和物理内存页就可以对应，实际上虚拟内存就是用于物理内存的临时存放的磁盘空间。页文件就是内存页，物理内存中每页叫物理页，磁盘上的页文件叫虚拟页，物理页+虚拟页就是系统所有使用的页文件的总和。</p>
<p>22、线程是否具有相同的堆栈？dll是否有独立的堆栈？</p>
<p>　　每个线程有自己的堆栈。</p>
<p>　　dll是否有独立的堆栈？这个问题不好回答，或者说这个问题本身是否有问题。因为dll中的代码是被某些线程所执行，只有线程拥有堆栈。如果dll中的代码是exe中的线程所调用，那么这个时候是不是说这个dll没有独立的堆栈？如果dll中的代码是由dll自己创建的线程所执行，那么是不是说dll有独立的堆栈？</p>
<p>　　以上讲的是堆栈，如果对于堆来说，每个dll有自己的堆，所以如果是从dll中动态分配的内存，最好是从dll中删除；如果你从dll中分配内存，然后在exe中，或者另外一个dll中删除，很有可能导致程序崩溃。</p>
<p>23、什么是缓冲区溢出？有什么危害？其原因是什么？</p>
<p>　　缓冲区溢出是指当计算机向缓冲区内填充数据时超过了缓冲区本身的容量，溢出的数据覆盖在合法数据上。</p>
<p>　　危害：在当前网络与分布式系统安全中，被广泛利用的50%以上都是缓冲区溢出，其中最著名的例子是1988年利用fingerd漏洞的蠕虫。而缓冲区溢出中，最为危险的是堆栈溢出，因为入侵者可以利用堆栈溢出，在函数返回时改变返回程序的地址，让其跳转到任意地址，带来的危害一种是程序崩溃导致拒绝服务，另外一种就是跳转并且执行一段恶意代码，比如得到shell，然后为所欲为。通过往程序的缓冲区写超出其长度的内容，造成缓冲区的溢出，从而破坏程序的堆栈，使程序转而执行其它指令，以达到攻击的目的。</p>
<p>　　造成缓冲区溢出的主原因是程序中没有仔细检查用户输入的参数。</p>
<p>24、什么是死锁？其条件是什么？怎样避免死锁？</p>
<p>　　死锁的概念：在两个或多个并发进程中，如果每个进程持有某种资源而又都等待别的进程释放它或它们现在保持着的资源，在未改变这种状态之前都不能向前推进，称这一组进程产生了死锁。通俗地讲，就是两个或多个进程被无限期地阻塞、相互等待的一种状态。</p>
<p>　　死锁产生的原因主要是：</p>
<pre><code>（1）系统资源不足；

（2） 进程推进顺序非法。
</code></pre><p>　　产生死锁的必要条件：</p>
<p>　　（1）互斥（mutualexclusion），一个资源每次只能被一个进程使用；</p>
<p>　　（2）不可抢占（nopreemption），进程已获得的资源，在未使用完之前，不能强行剥夺；</p>
<p>　　（3）占有并等待（hold andwait），一个进程因请求资源而阻塞时，对已获得的资源保持不放；</p>
<p>　　（4）环形等待（circularwait），若干进程之间形成一种首尾相接的循环等待资源关系。</p>
<p>　　这四个条件是死锁的必要条件，只要系统发生死锁，这些条件必然成立，而只要上述条件之一不满足，就不会发生死锁。</p>
<p>　　死锁的解除与预防：理解了死锁的原因，尤其是产生死锁的四个必要条件，就可以最大可能地避免、预防和解除死锁。所以，在系统设计、进程调度等方面注意如何不让这四个必要条件成立，如何确定资源的合理分配算法，避免进程永久占据系统资源。此外，也要防止进程在处于等待状态的情况下占用资源。因此，对资源的分配要给予合理的规划。</p>
<p>　　死锁的处理策略：鸵鸟策略、预防策略、避免策略、检测与恢复策略。</p>
<h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h2><h3 id="请简述TCP-UDP的区别"><a href="#请简述TCP-UDP的区别" class="headerlink" title="请简述TCP\UDP的区别"></a>请简述TCP\UDP的区别</h3><ul>
<li>TCP和UDP是OSI模型中的运输层中的协议。TCP提供可靠的通信传输，而UDP则常被用于让广播和细节控制交给应用的通信传输。<br>两者的区别大致如下：</li>
<li>TCP面向连接，UDP面向非连接即发送数据前不需要建立链接</li>
<li>TCP提供可靠的服务（数据传输），UDP无法保证</li>
<li>TCP面向字节流，UDP面向报文</li>
<li>TCP数据传输慢，UDP数据传输快</li>
</ul>
<h3 id="请简单说一下你了解的端口及对应的服务？"><a href="#请简单说一下你了解的端口及对应的服务？" class="headerlink" title="请简单说一下你了解的端口及对应的服务？"></a>请简单说一下你了解的端口及对应的服务？</h3><p><img src="https://raw.githubusercontent.com/wtligit/pic-repo/master/pic/port.jpg" alt=""></p>
<h3 id="说一说TCP的三次握手"><a href="#说一说TCP的三次握手" class="headerlink" title="说一说TCP的三次握手"></a>说一说TCP的三次握手</h3><p><img src="https://raw.githubusercontent.com/wtligit/pic-repo/master/pic/3hand.jpg" alt=""></p>
<h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><ul>
<li>与建立连接的“三次握手”类似，断开一个TCP连接则需要“四次握手”。</li>
<li>第一次挥手：主动关闭方发送一个FIN，用来关闭主动方到被动关闭方的数据传送，也就是主动关闭方告诉被动关闭方：我已经不会再给你发数据了(当然，在fin包之前发送出去的数据，如果没有收到对应的ack确认报文，主动关闭方依然会重发这些数据)，但是，此时主动关闭方还可以接受数据。</li>
<li>第二次挥手：被动关闭方收到FIN包后，发送一个ACK给对方，确认序号为收到序号+1。</li>
<li>第三次挥手：被动关闭方发送一个FIN，用来关闭被动关闭方到主动关闭方的数据传送，也就是告诉主动关闭方，我的数据也发送完了，不会再给你发数据了。（与SYN相同，一个FIN占用一个序号）。</li>
<li>第四次挥手：主动关闭方收到FIN后，发送一个ACK给被动关闭方，确认序号为收到序号+1，至此，完成四次挥手。</li>
</ul>
<h3 id="有哪些私有（保留）地址？"><a href="#有哪些私有（保留）地址？" class="headerlink" title="有哪些私有（保留）地址？"></a>有哪些私有（保留）地址？</h3><ul>
<li>A类：10.0.0.0 - 10.255.255.255</li>
<li>B类：172.16.0.0 - 172.31.255.255</li>
<li>C类：192.168.0.0 - 192.168.255.255</li>
</ul>
<h3 id="IP地址分为哪几类？简单说一下各个分类"><a href="#IP地址分为哪几类？简单说一下各个分类" class="headerlink" title="IP地址分为哪几类？简单说一下各个分类"></a>IP地址分为哪几类？简单说一下各个分类</h3><p><img src="https://raw.githubusercontent.com/wtligit/pic-repo/master/pic/ipAddress.jpg" alt=""></p>
<h3 id="在浏览器中输入网址之后执行会发生什么？"><a href="#在浏览器中输入网址之后执行会发生什么？" class="headerlink" title="在浏览器中输入网址之后执行会发生什么？"></a>在浏览器中输入网址之后执行会发生什么？</h3><ul>
<li>查找域名对应的IP地址。这一步会依次查找浏览器缓存，系统缓存，路由器缓存，ISPNDS缓存，根域名服务器</li>
<li>浏览器向IP对应的web服务器发送一个HTTP请求</li>
<li>服务器响应请求，发回网页内容</li>
<li>浏览器解析网页内容<br><img src="https://raw.githubusercontent.com/wtligit/pic-repo/master/pic/website.jpg" alt=""></li>
</ul>
<h3 id="简单解释一些ARP协议的工作过程"><a href="#简单解释一些ARP协议的工作过程" class="headerlink" title="简单解释一些ARP协议的工作过程"></a>简单解释一些ARP协议的工作过程</h3><p><img src="https://raw.githubusercontent.com/wtligit/pic-repo/master/pic/ARP.jpg" alt=""></p>
<h3 id="HTTP-协议包括哪些请求？"><a href="#HTTP-协议包括哪些请求？" class="headerlink" title="HTTP 协议包括哪些请求？"></a>HTTP 协议包括哪些请求？</h3><ul>
<li>GET：对服务器资源的简单请求</li>
<li>POST：用于发送包含用户提交数据的请求</li>
<li>HEAD：类似于GET请求，不过返回的响应中没有具体内容，用于获取报头</li>
<li>PUT：传说中请求文档的一个版本</li>
<li>DELETE：发出一个删除指定文档的请求</li>
<li>TRACE：发送一个请求副本，以跟踪其处理进程</li>
<li>OPTIONS：返回所有可用的方法，检查服务器支持哪些方法</li>
<li>CONNECT：用于ssl隧道的基于代理的请求</li>
</ul>
<h3 id="简述HTTP中GET和POST的区别"><a href="#简述HTTP中GET和POST的区别" class="headerlink" title="简述HTTP中GET和POST的区别"></a>简述HTTP中GET和POST的区别</h3><ul>
<li>从原理性看：<br>根据HTTP规范，GET用于信息获取，而且应该是安全和幂等的<br>根据HTTP规范，POST请求表示可能修改服务器上资源的请求</li>
<li>从表面上看：<br>GET请求的数据会附在URL后面，POST的数据放在HTTP包体<br>POST安全性比GET安全性高</li>
</ul>
<h3 id="TCP对应的协议和UDP对应的协议"><a href="#TCP对应的协议和UDP对应的协议" class="headerlink" title="TCP对应的协议和UDP对应的协议"></a>TCP对应的协议和UDP对应的协议</h3><ul>
<li>TCP对应的协议：<br>（1） FTP：定义了文件传输协议，使用21端口。<br>（2） Telnet：一种用于远程登陆的端口，使用23端口，用户可以以自己的身份远程连接到计算机上，可提供基于DOS模式下的通信服务。<br>（3） SMTP：简单邮件传送协议，用于发送邮件。服务器开放的是25号端口。<br>（4） POP3：它是和SMTP对应，POP3用于接收邮件。POP3协议所用的是110端口。<br>（5） HTTP：是从Web服务器传输超文本到本地浏览器的传送协议。 </li>
<li>UDP对应的协议：<br>（1） DNS：用于域名解析服务，将域名地址转换为IP地址。DNS用的是53号端口。<br>（2） SNMP：简单网络管理协议，使用161号端口，是用来管理网络设备的。由于网络设备很多，无连接的服务就体现出其优势。<br>（3） TFTP：简单文件传输协议，该协议在熟知端口69上使用UDP服务。</li>
</ul>
<h3 id="面试题精选"><a href="#面试题精选" class="headerlink" title="面试题精选"></a>面试题精选</h3><p>例题1：TCP和UDP有什么区别？<br>TCP是传输控制协议，提供的是面向连接、可靠的字节流服务。当客户和服务器批次交换数据前，必须建立TCP连接之后才能传输数据。TCP提供超时重传、丢弃重复数据、流量控制等功能，保证数据能从一端传到另一端。</p>
<p>UDP是用户数据报协议，是一个简单的面向数据报的运输层协议。UDP不提供可靠性，不保证数据能够到达目的地。由于UDP在传输数据前不用在客户和服务器之间建立连接，且没有超时重传等机制，故而传输速度很快。</p>
<p>例题2：TCP的可靠性如何保证？<br>TCP的可靠性是通过顺序编号和确认（ACK）来实现的。</p>
<p>例题3：在浏览器中输入www.baidu.com后执行的全部过程<br>客户端浏览器通过DNS解析到www.baidu.com的IP地址220.181.27.48，通过这个IP地址找到客户端到服务器的路径。客户端浏览器发起一个HTTP会话到220.161.27.48，然后通过TCP进行封装数据包，输入到网络层。<br>在客户端的传输层，把HTTP会话请求分成报文段，添加源和目的端口，如服务器使用80端口监听客户端的请求，客户端由系统随机选择一个端口如5000，与服务器进行交换，服务器把相应的请求返回给客户端的5000端口。然后使用IP层的IP地址查找目的端。<br>客户端的网络层不用关系应用层或者传输层的东西，主要做的是通过查找路由表确定如何到达服务器，期间可能经过多个路由器，这些都是由路由器来完成的工作，我不作过多的描述，无非就是通过查找路由表决定通过那个路径到达服务器。<br>客户端的链路层，包通过链路层发送到路由器，通过邻居协议查找给定IP地址的MAC地址，然后发送ARP请求查找目的地址，如果得到回应后就可以使用ARP的请求应答交换的IP数据包现在就可以传输了，然后发送IP数据包到达服务器的地址。<br>例题4：牛客网由于访问客户量的增长,原来的服务器不足以维持请求,经常发生宕机的突发情况,因此为了解决这个问题,CEO决定新增加几台服务器,那么问题是这些接入WEB服务器第一次被访问到时，不同协议的发生顺序是下面中的（ARP -&gt; DNS -&gt; HTTP）。<br>解析：当你给WEB服务器接上网线的时候，它会自动发送一条ARP信息，使得接入网关能找的到它；网关上会形成一条MAC地址到IP地址的映射记录。如用户在浏览器中输入域名，如本地DNS缓存中没有，必然会进行一次DNS查询，以确定该域名的IP地址。获得DNS对应的IP地址以后，使用HTTP协议访问web服务器（不考虑TCP三次握手建立连接的阶段）。</p>
<p>例题5：将一个C类网络划分为3个子网，每个子网最少要容纳55台主机，使用的子网掩码是？（2017乐视实习生）<br>答：255.255.255.192</p>
<p>例题5：IP路由表包括哪几项内容？<br>IP路由表通常包括三项内容，他们是子网掩码、目的网络地址、到目的网络路径上“下一个”路由器的地址。</p>
<h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><h3 id="什么是存储过程？有哪些优缺点？"><a href="#什么是存储过程？有哪些优缺点？" class="headerlink" title="什么是存储过程？有哪些优缺点？"></a>什么是存储过程？有哪些优缺点？</h3><ul>
<li>存储过程是一些预编译的SQL语句。</li>
<li>更加直白的理解：存储过程可以说是一个记录集，它是由一些T-SQL语句组成的代码块，这些T-SQL语句代码像一个方法一样实现一些功能（对单表或多表的增删改查），然后再给这个代码块取一个名字，在用到这个功能的时候调用他就行了。</li>
<li>存储过程是一个预编译的代码块，执行效率比较高</li>
<li>一个存储过程替代大量T_SQL语句 ，可以降低网络通信量，提高通信速率</li>
<li>可以一定程度上确保数据安全</li>
</ul>
<h3 id="索引是什么？有什么作用以及优缺点？"><a href="#索引是什么？有什么作用以及优缺点？" class="headerlink" title="索引是什么？有什么作用以及优缺点？"></a>索引是什么？有什么作用以及优缺点？</h3><ul>
<li>索引是对数据库表中一或多个列的值进行排序的结构，是帮助MySQL高效获取数据的数据结构</li>
<li>你也可以这样理解：索引就是加快检索表中数据的方法。数据库的索引类似于书籍的索引。在书籍中，索引允许用户不必翻阅完整个书就能迅速地找到所需要的信息。在数据库中，索引也允许数据库程序迅速地找到表中的数据，而不必扫描整个数据库。</li>
<li>MySQL数据库几个基本的索引类型：普通索引、唯一索引、主键索引、全文索引</li>
<li>索引加快数据库的检索速度</li>
<li>索引降低了插入、删除、修改等维护任务的速度</li>
<li>唯一索引可以确保每一行数据的唯一性</li>
<li>通过使用索引，可以在查询的过程中使用优化隐藏器，提高系统的性能</li>
<li>索引需要占物理和数据空间 </li>
</ul>
<h3 id="什么是事务？"><a href="#什么是事务？" class="headerlink" title="什么是事务？"></a>什么是事务？</h3><ul>
<li>事务（Transaction）是并发控制的基本单位。所谓的事务，它是一个操作序列，这些操作要么都执行，要么都不执行，它是一个不可分割的工作单位。事务是数据库维护数据一致性的单位，在每个事务结束时，都能保持数据一致性。</li>
<li>事务应该具有4个属性：原子性、一致性、隔离性、持久性。</li>
</ul>
<h3 id="数据库的乐观锁和悲观锁是什么？"><a href="#数据库的乐观锁和悲观锁是什么？" class="headerlink" title="数据库的乐观锁和悲观锁是什么？"></a>数据库的乐观锁和悲观锁是什么？</h3><ul>
<li>数据库管理系统（DBMS）中的并发控制的任务是确保在多个事务同时存取数据库中同一数据时不破坏事务的隔离性和统一性以及数据库的统一性。</li>
<li>乐观并发控制(乐观锁)和悲观并发控制（悲观锁）是并发控制主要采用的技术手段。<br>悲观锁：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作<br>乐观锁：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。</li>
</ul>
<h3 id="使用索引查询一定能提高查询的性能吗？为什么"><a href="#使用索引查询一定能提高查询的性能吗？为什么" class="headerlink" title="使用索引查询一定能提高查询的性能吗？为什么"></a>使用索引查询一定能提高查询的性能吗？为什么</h3><ul>
<li>通常,通过索引查询数据比全表扫描要快.但是我们也必须注意到它的代价.</li>
<li>索引需要空间来存储,也需要定期维护, 每当有记录在表中增减或索引列被修改时,索引本身也会被修改. 这意味着每条记录的INSERT,DELETE,UPDATE将为此多付出4,5 次的磁盘I/O. 因为索引需要额外的存储空间和处理,那些不必要的索引反而会使查询反应时间变慢.使用索引查询不一定能提高查询性能,索引范围查询(INDEX RANGE SCAN)适用于两种情况:<br>基于一个范围的检索,一般查询返回结果集小于表中记录数的30%<br>基于非唯一性索引的检索</li>
</ul>
<h3 id="简单说一说drop、delete与truncate的区别"><a href="#简单说一说drop、delete与truncate的区别" class="headerlink" title="简单说一说drop、delete与truncate的区别"></a>简单说一说drop、delete与truncate的区别</h3><ul>
<li>SQL中的drop、delete、truncate都表示删除，但是三者有一些差别</li>
<li>delete和truncate只删除表的数据不删除表的结构</li>
<li>速度,一般来说: drop&gt; truncate &gt;delete </li>
<li>delete语句是dml,这个操作会放到rollback segement中,事务提交之后才生效;<br>如果有相应的trigger,执行的时候将被触发. truncate,drop是ddl, 操作立即生效,原数据不放到rollback segment中,不能回滚. 操作不触发trigger.</li>
</ul>
<h3 id="drop、delete与truncate分别在什么场景之下使用？"><a href="#drop、delete与truncate分别在什么场景之下使用？" class="headerlink" title="drop、delete与truncate分别在什么场景之下使用？"></a>drop、delete与truncate分别在什么场景之下使用？</h3><ul>
<li>不再需要一张表的时候，用drop</li>
<li>想删除部分数据行时候，用delete，并且带上where子句</li>
<li>保留表而删除所有数据的时候用truncate</li>
</ul>
<h3 id="超键、候选键、主键、外键分别是什么？"><a href="#超键、候选键、主键、外键分别是什么？" class="headerlink" title="超键、候选键、主键、外键分别是什么？"></a>超键、候选键、主键、外键分别是什么？</h3><ul>
<li>超键：在关系中能唯一标识元组的属性集称为关系模式的超键。一个属性可以为作为一个超键，多个属性组合在一起也可以作为一个超键。超键包含候选键和主键。</li>
<li>候选键：是最小超键，即没有冗余元素的超键。</li>
<li>主键：数据库表中对储存数据对象予以唯一和完整标识的数据列或属性的组合。一个数据列只能有一个主键，且主键的取值不能缺失，即不能为空值（Null）。</li>
<li>外键：在一个表中存在的另一个表的主键称此表的外键。</li>
</ul>
<h3 id="什么是视图？以及视图的使用场景有哪些？"><a href="#什么是视图？以及视图的使用场景有哪些？" class="headerlink" title="什么是视图？以及视图的使用场景有哪些？"></a>什么是视图？以及视图的使用场景有哪些？</h3><ul>
<li>视图是一种虚拟的表，具有和物理表相同的功能。可以对视图进行增，改，查，操作，试图通常是有一个表或者多个表的行或列的子集。对视图的修改不影响基本表。它使得我们获取数据更容易，相比多表查询。</li>
<li>只暴露部分字段给访问者，所以就建一个虚表，就是视图。</li>
<li>查询的数据来源于不同的表，而查询者希望以统一的方式查询，这样也可以建立一个视图，把多个表查询结果联合起来，查询者只需要直接从视图中获取数据，不必考虑数据来源于不同表所带来的差异</li>
</ul>
<h3 id="说一说三个范式"><a href="#说一说三个范式" class="headerlink" title="说一说三个范式"></a>说一说三个范式</h3><ul>
<li>第一范式（1NF）：数据库表中的字段都是单一属性的，不可再分。这个单一属性由基本类型构成，包括整型、实数、字符型、逻辑型、日期型等。</li>
<li>第二范式（2NF）：数据库表中不存在非关键字段对任一候选关键字段的部分函数依赖（部分函数依赖指的是存在组合关键字中的某些字段决定非关键字段的情况），也即所有非关键字段都完全依赖于任意一组候选关键字。</li>
<li>第三范式（3NF）：在第二范式的基础上，数据表中如果不存在非关键字段对任一候选关键字段的传递函数依赖则符合第三范式。所谓传递函数依赖，指的是如 果存在”A → B → C”的决定关系，则C传递函数依赖于A。因此，满足第三范式的数据库表应该不存在如下依赖关系： 关键字段 → 非关键字段 x → 非关键字段y</li>
</ul>
</div><div class="tags"></div><div class="post-nav"><a class="pre" href="/2018/02/26/VLOOKUP/">Excel怎样把相同列数据合并到一行</a><a class="next" href="/2018/01/30/UT-easymock/">单元测试整理（六）—— 使用EasyMock和JUnit进行单元测试</a></div><div id="disqus_thread"><div class="btn_click_load"><button class="disqus_click_btn">阅读评论 「请确保 disqus.com 可以正常加载」</button></div><script>var disqus_shortname = 'wtli';
var disqus_identifier = '2018/02/02/Interview/';
var disqus_title = '面试知识整理';
var disqus_url = 'http://yoursite.com/2018/02/02/Interview/';
$('.btn_click_load').click(function() {
  (function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
  $('.btn_click_load').css('display','none');
});
$.ajax({
  url: 'https://disqus.com/next/config.json',
  timeout: 3000,
  type: 'GET',
  success: (function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    $('.btn_click_load').css('display','none');
  })(),
  error: function() {
    $('.btn_click_load').css('display','block');
  }
});</script><script id="dsq-count-scr" src="//wtli.disqus.com/count.js" async></script></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://yoursite.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/03/15/treeTraverse/">二叉树的四种遍历</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/03/12/C++/">C++知识汇总</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/03/11/Sort/">数据结构中十种经典排序方法汇总(C++)</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/03/10/Datastructure/">数据结构知识整理</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/02/26/VLOOKUP/">Excel怎样把相同列数据合并到一行</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/02/02/Interview/">面试知识整理</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/01/30/UT-easymock/">单元测试整理（六）—— 使用EasyMock和JUnit进行单元测试</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/01/29/UT-what/">单元测试整理（一）——单元测试是什么，有什么好处</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/01/29/UT-mock/">单元测试整理（五）—— Mock篇，测试一个servlet</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/01/29/UT-content/">单元测试整理（四）——测试哪些内容及边界条件</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-comment-o"> 最近评论</i></div><script type="text/javascript" src="//wtli.disqus.com/recent_comments_widget.js?num_items=5&amp;hide_avatars=1&amp;avatar_size=32&amp;excerpt_length=20&amp;hide_mods=1"></script></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://github.com/wtligit" title="GitHub" target="_blank">GitHub</a><ul></ul><a href="http://blog.csdn.net/potatostyles" title="CSDN" target="_blank">CSDN</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">Page of Wentao Li.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.2.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.2.5/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>